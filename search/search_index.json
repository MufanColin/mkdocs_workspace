{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Colin Mufan's wonderland","text":"<p>There are tons of amazing study materials here.</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/","title":"Digital Design and Computer Architecture(!!!)","text":"<p>Digital Design and Computer Architecture</p> <p></p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#1-from-zero-to-one","title":"1 From Zero to One","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#10-exercises","title":"1.0 Exercises","text":"<p>Exercises 1 Checklist</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#11-the-game-plan","title":"1.1 The Game Plan","text":"\ud83d\udcd6 **Key Ideas**  - We believe that microprocessors are not only technically, economically, and socially important, but are also an **intrinsically fascinating human invention**. - We assume that you have a basic familiarity with electricity, some prior programming experience, and **a genuine interest in understanding what goes on under the hood of a computer**. - The designer\u2019s challenge is to **combine these simple blocks into complicated systems**. - One of the major themes weaved through this book is **how to manage complexity**.   \ud83d\udcd6 **Study pattern**  - We begin with **digital logic gates** that accept 1\u2019s and 0\u2019s as inputs and produce 1\u2019s and 0\u2019s as outputs. - We then explore how to **combine logic gates into more complicated modules** such as adders and memories. - Then we shift gears to **programming in assembly language**, the native tongue of the microprocessor. - Finally, we **put gates together to build a microprocessor** that runs these assembly language programs."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#12-the-art-of-managing-complexity","title":"1.2 The Art of Managing Complexity","text":"\ud83d\udccc **One of the characteristics that separates an engineer or computer scientist from a layperson is a systematic approach to managing complexity.**"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#121-abstraction","title":"1.2.1 Abstraction(!!!)","text":"\ud83d\udccc **The critical technique for managing complexity is *abstraction*: hiding details when they are not important.**    \ud83d\udcd6 **Levels of abstraction for an electronic computing system**  ![Screenshot 2023-01-18 at 10.04.15.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-18_at_10.04.15.png)    \ud83d\udcd6 **Detailed Explanations**  1. At the lowest level of abstraction is the physics, **the motion of electrons**. 2. Our system is constructed from **electronic devices** such as transistors. These devices have well-defined connection points called ***terminals*** and can be modeled by the relationship between voltage and current as measured at each terminal. 3. The next level of abstraction is **analog circuits**, in which devices are assembled to create components such as amplifiers. Analog circuits **input and output a continuous range of voltages**. 4. **Digital circuits** such as logic gates **restrict the voltages to discrete ranges**, which we will use to indicate 0 and 1. 5. In logic design, we build **more complex structures**, such as **adders or memories**, from digital circuits. 6. **Microarchitecture** **links the logic and architecture levels of abstraction**. Microarchitecture involves **combing logic elements to execute the instructions defined by the architecture**.  7. The **architecture level** of abstraction describes a computer **from the programmer\u2019s perspective**. For example, the Intel x86 architecture used by microprocessors in most *personal computers*(*PCs*) is defined by a ***set of instructions*** and ***registers***(***memory for temporarily storing variables***) that the programmer is allowed to use. **A particular architecture can be implemented by one of many different microarchitectures with different price/performance/power trade-offs.** 8. Moving into the **software realm**, the **operating system** handles **low-level details such as accessing a hard drive or managing memory**.  9. Finally, **the application software** uses these facilities provided by the operating system to solve a problem for the user.   \ud83d\udcd6 Things to keep in mind  - This book focuses on **the levels of abstraction from digital circuits through computer architecture**. - **When you are working at one level of abstraction, it is good to know something about the levels of abstraction immediately above and below where you are working**."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#122-discipline","title":"1.2.2  Discipline(?)","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#123-the-three-ys","title":"1.2.3 The Three-Y\u2019s","text":"\ud83d\udcd6 In addition to abstraction and discipline, designers use the three \u201c-y\u2019s\u201d to manage complexity: **hierarchy**, **modularity**, and **regularity**. These principles apply to both software and hardware systems.  - **Hierarchy**      Hierarchy involves **dividing a system into modules**, then further **sub-dividing each of these modules** until the pieces are easy to understand.   - Modularity      Modularity states that the **modules have well-defined functions and interfaces**, so that they connect together easily without unanticipated side effects.   - Regularity      Regularity **seeks uniformity among the modules**. Common modules are reused many times, reducing the number of distinct modules that must be designed."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#13-the-digital-abstraction","title":"1.3 The Digital Abstraction","text":"\ud83d\udcd6 **Important takeaways**  - Digital systems represent information with **discrete-valued variables** \u2014 that is, variables with a **finite number** of **distinct values**. - Most electronic computers use a binary(two-valued) representation in which a high voltage indicates a \u20181\u2019 and a low voltage indicates a \u20180\u2019, because it is a easier to distinguish between two voltages than ten. - The ***amount of information*** $D\\,$in a discrete valued variable with $N\\,$distinct states is measured in units of ***bits*** as      $$     D=\\log _2N \\text \\space\\space\\text{bits}     $$"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#14-number-systems","title":"1.4 Number Systems(!!!)","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#140-overview","title":"1.4.0 Overview(!!!)","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#142-binary-numbers","title":"1.4.2 Binary Numbers","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#143-hexadecimal-numbers","title":"1.4.3 Hexadecimal Numbers","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#144-bytes-nibbles-and-all-that-jazz","title":"1.4.4 Bytes, Nibbles, and All That Jazz","text":"\ud83d\udcd6 **Important takeaways**  - **Conversion**      A group of **eight bits** is called a ***byte***. It represents one of $\\,2^8=256\\,$possibilities. The size of objects stored in computer memories is customarily measured in bytes rather than bits.      $$     \\begin{align*}1\\,\\text{byte}&amp;=8\\,\\text{bits}=2\\,\\text{hexadecimal digits}\\\\0.5 \\,\\text{byte}&amp;=4\\,\\text{bits}=1\\,\\text{hexadecimal digit}=1 \\,\\text{nibble}\\end{align*}     $$  - **Words**      Microprocessors handle data in chunks called ***words***. **The size of a word depends on the architecture of the microprocessor**. When this chapter was written in 2012, most computers had 64-bit processors, indicating that they operate in **64-bit** words. At the time, older computers handling 32-bit words were also widely available. Simpler microprocessors, especially those used in gadgets such as toasters, use 8- or 16-bit words.   - **Least significant bit(lsb), most significant bit(msb), least significant byte(LSB), most significant byte(MSB)**      ![Screenshot 2023-01-18 at 11.37.06.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-18_at_11.37.06.png)  - **Background Information**      **A microprocessor is a processor built on a single chip**. Until 1970\u2019s, processors were too complicated to fit on one chip, so mainframe processors were built from boards containing many chips. Intel introduced the first 4-bit microprocessor, called the 4004, in 1971. Now, even the most sophisticated supercomputers are built using microprocessors."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#145-binary-addition","title":"1.4.5 Binary Addition","text":"\ud83d\udcd6 **Important takeaways**  - **Overflow**      Digital system usually operate on a fixed number of digits. Addition is said to ***overflow*** if the result is too big to fit in the available digits. A 4-bit number, for example, has the range $[0,15]\\,$. 4-bit binary addition overflows if the result exceeds 15. The fifth bit is discarded, producing an incorrect result in the remaining four bits. Overflow can be detected by checking for a carry out of the most significant column.      $$     \\begin{align*}1101_2+0101_2&amp;=10010_2\\\\7+5&amp;=12\\end{align*}     $$      **This result overflows the range of a 4-bit binary number**."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#146-signed-binary-numbers","title":"1.4.6 Signed Binary Numbers(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - **Lead in**      So far, we have considered only ***unsigned binary numbers*** that represent positive quantities. We will often want to represent both positive and negative numbers, requiring a different binary number system. Several schemes exist to represent signed binary number; the two most widely employed are called **sign/magnitude** and **two\u2019s complement**.  - **Sign/Magnitude Numbers(Not very good)**     - Sign/magnitude numbers are intuitively appealing because they match our custom of writing negative numbers with a minus sign followed by the magnitude.     - An $N$-bit sign/magnitude number uses the most significant bit as the sign and the remaining $N-1\\,$bits as the magnitude(absolute value). A sign bit of $0$ indicates positive and a sign bit of $1\\,$indicates negative.     - Unfortunately, **ordinary binary addition does not work for sign/magnitude numbers**. For example, using ordinary addition on $-5_{10}+5_{10}\\,$gives          $$         \\begin{align*}1101_{2}+0101_{2}&amp;=10010_{2}\\\\-5_{10}+5_{10}&amp;=-2_{10}\\end{align*}         $$          , which is nonsense.      - An $N$-bit sign/magnitude number spans the range $[-2^{N-1}+1,2^{N-1}-1]\\,$. **Sign/magnitude numbers are slightly odd in that both $+0\\,$and $-0\\,$exist**. Both indicating zero. As you may expect, it can be troublesome to have two different representations for the same number. - **Two\u2019s Complement Numbers(Much better)**     - Two\u2019s complement numbers are identical to unsigned binary numbers **except that the most significant bit position has a weight of $-2^{N-1}\\,$instead of$\\,2^{N-1}\\,$**. They overcome the shortcomings of sign/magnitude numbers: **zero has a single representation, and ordinary addition works**.     - In two\u2019s complement representation:         - Zero is written as all zeros: $00\\cdots000_2\\,$.         - The most positive number has a $0\\,$in the most significant position and $1$\u2019s elsewhere: $\\underbrace{01\\cdots 111}_{N \\,\\text{digits}}{\\scriptscriptstyle{2}}=2^{N-1}-1$.         - The most negative number has a $1\\,$in the most significant position and $0$\u2019s elsewhere: $\\underbrace{10\\cdots 000}_{N \\,\\text{digits}}{\\scriptscriptstyle{2}}=-2^{N-1}$.     - Notice that positive numbers have a $0\\,$in the most significant position and negative numbers have a $1\\,$in this position, so **the most significant bit can be viewed as the sign bit**.     - The two\u2019s complement of $0\\,$is found by inverting all the bits(producing $\\underbrace{11\\cdots 111}_{N \\,\\text{digits}}{\\scriptscriptstyle{2}}$) and adding $1$, which produces all $0$\u2019s, **disregarding the carry out of the most significant bit position**. Hence, zero is always represented with all $0$\u2019s.     - Unlike the sign/magnitude system, the two\u2019s complement system has no separate $-0$. Zero is **considered** positive because its sign bit is $0$.     - The range of an $N$-bit two\u2019s complement number spans $[-2^{N-1},2^{N-1}-1]$. It should make sense that there is one more negative number than positive number($0\\,$not included) because there is no $-0\\,$. - **Taking the two\u2019s complement(!!!)**     - **The sign** of a two\u2019s complement number is **reversed** in a process called ***taking the two\u2019s complement***. The process consists of **inverting all of the bits** in the number, then **adding $1\\,$to the least significant bit position**(**disregarding the carry out of the most significant bit position**). This is useful to find the representation of a negative number or to determine the magnitude of a negative number.         - Examples             - Find the representation of $-2_{10}\\,$as a $4$-bit two\u2019s complement number.                  $$                 0010_2\\xRightarrow[\\text{all the bits}]{\\text{inverting }}1101_2\\xRightarrow[\\text{disregard the carry out of the msb}]{\\text{add one}}1110_2=-2_{10}                 $$              - Find the decimal value of the two\u2019s complement number $1001_2\\,$.(**We can take the two\u2019s complement of a negative number as well**)                  $$                 -7_{10}=1001_2\\xRightarrow[\\text{all the bits}]{\\text{inverting }}0110_2\\xRightarrow[\\text{disregard the carry out of the msb}]{\\text{add one}}0111_2=7_{10}                 $$              - Compute$\\,-2_{10}+1_{10}\\,$and $-7_{10}+7_{10}\\,$using two\u2019s complement numbers.                  &gt; **When adding $N$-bit numbers, the carry out of the $N$th bit is discarded.**                 &gt;                   $$                 \\begin{align*}-2_{10}+1_{10}&amp;=1110_{2}+0001_{2}=1111_{2}=-1_{10}\\\\-7_{10}+7_{10}&amp;=1001_{2}+0111_{2}=0000_{2}=0_{10}\\end{align*}                 $$      - **Subtraction is performed by taking the two\u2019s complement of the second number, then adding**.         - Compute$\\,5_{10}-3_{10}\\,$and $3_{10}-5_{10}\\,$using two\u2019s complement numbers.              $$             \\begin{align*}5_{10}-3_{10}&amp;=0101_{2}-0011_{2}=0101_2+1101_2=0010_2=2_{10}\\\\3_{10}-5_{10}&amp;=0011_{2}-0101_{2}=0011_{2}+1011_2=1110_2=-2_{10}\\end{align*}             $$  - **Overflow(!!!)**     - Adding two $N$-bit positive numbers or negative numbers may cause overflow if the result is greater than $2^{N-1}-1\\,$or less than $-2^{N-1}\\,$. **Adding** a **positive** number to a **negative** number **never causes overflow**.     - **Unlike unsigned numbers, a carry out of the most significant column does not indicate overflow**.          $$         -1_{10}+7_{10}=1111_2+0111_2=0110_2=6_{10}         $$      - Overflow occurs if the **two numbers being added** have the **same sign bit** and the **result** has the **opposite sign bit**.         - Example             - Compute$\\,4_{10}+5_{10}\\,$using $4$-bit two\u2019s complement numbers. Does the result overflow?                  $$                 4_{10}+5_{10}=0100_2+0101_2=1001_2=-7_{10}                 $$                  The result overflows the range of $4$-bit positive two\u2019s complement numbers, producing an incorrect negative result. If the computation had been done using five or more bits, the result would have been correct.                  $$                 4_{10}+5_{10}=00100_2+00101_2=01001_2=9_{10}                 $$  - **Sign extension(!!!)**     - When a two\u2019s complement number is extended to more bits, the sign bits must be **copied** into the most significant bit position**s**. This process is called ***sign extension***.     - For example, the number $3\\,$and $-3\\,$are written as $4$-bit two\u2019s complement numbers $0011\\,$and $1101$, respectively. They are **sign-extended to seven bits** by **copying** the sign bit into the **three new upper bits** to form $0000011\\,$and $1111101$, respectively.          $$         \\begin{align*}3_{10}&amp;=0011_2=0000011_2\\\\-3_{10}&amp;=1101_2=1111101_2\\end{align*}         $$"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#15-logic-gates","title":"1.5 Logic Gates","text":"\ud83d\udcd6 **Important takeaways**  - ***Logic gates*** are simple **digital circuits** that take **one or more binary inputs** and produce **a binary output**. - Logic gates are drawn with a symbol showing the input(or inputs) and the output. Inputs are usually drawn on the left(or top) and outputs on the right(or bottom). - Digital designers typically use **letters near the beginning of the alphabet** for **gate inputs** and the letter $Y\\,$for the **gate output**. - The relationship between the inputs and the output can be described with a truth table or a Boolean equation. - A truth table lists inputs on the left and the corresponding output on the right. It has **one row** for **each possible combination of inputs**. - A Boolean equation is a mathematical expression using binary variables."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#151-not-gate","title":"1.5.1 NOT Gate","text":"<ul> <li> <p>Visualization</p> <ol> <li>The triangle symbol indicates a buffer.</li> <li>A circle on the output is called a bubble and indicates inversion, as was seen in the NOT gate symbol. </li> </ol> <p></p> </li> <li> <p>Explanation</p> <p></p> </li> </ul>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#152-bufferit-copies-the-input-to-the-output","title":"1.5.2 Buffer(It copies the input to the output)","text":"<ul> <li> <p>Visualization</p> <p></p> </li> <li> <p>Explanation</p> <p></p> </li> </ul>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#153-and-gateyab","title":"1.5.3 AND Gate(Y=AB)","text":"<ul> <li> <p>Visualization</p> <p></p> </li> <li> <p>Explanation</p> <p></p> </li> </ul>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#154-or-gateyab","title":"1.5.4 OR Gate(Y=A+B)","text":"<ul> <li> <p>Visualization</p> <p></p> </li> <li> <p>Explanation</p> <p></p> </li> </ul>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#155-other-two-input-gatesxor-nand-nor-xnor","title":"1.5.5 Other Two-Input Gates(XOR, NAND, NOR, XNOR)","text":"<ul> <li> <p>Visualization</p> <p></p> <p></p> <p></p> </li> <li> <p>Explanation</p> <p> \ud83d\udcd6 An $N$-input XOR gate is sometimes called a parity gate and produces a TRUE output if an odd number of inputs are TRUE. <p> \ud83d\udcd6 The two-input XNOR gate is sometimes called an equality gate because its output is TRUE when the inputs are equal. <p></p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#156-multiple-input-gatesand-or-xor-nand-nor-xnor","title":"1.5.6 Multiple-Input Gates(AND, OR, XOR, NAND, NOR, XNOR)","text":"<ul> <li> <p>Explanation</p> <p> \ud83d\udcd6 Many Boolean functions of three or more inputs exist. The most common are AND, OR, XOR, NAND, NOR, and XNOR. An $N$-input AND gate produces a TRUE output when all $N\\,$inputs are TRUE. An $N$-input OR gate produces a TRUE output when at least one input is TRUE. <li> <p>Visualization</p> <p></p> <p></p> <p></p> <p></p> </li>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#2-combinational-logic-design","title":"2 Combinational Logic Design","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#20-exercises","title":"2.0 Exercises","text":"<p>Exercises 2 Checklist</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#21-introduction","title":"2.1 Introduction(!!!)","text":"\ud83d\udcd6 **Circuit**  - In digital electronics, a ***circuit*** is a ***network that processes discrete-valued variables***. - A circuit can be viewed as a black box, with     1. one or more discrete-valued input terminals     2. one or more discrete-valued output terminals     3. a functional specification describing the relationship between inputs and outputs     4. a timing specification describing the delay between inputs changing and outputs responding - **Digital circuits** are classified as **combinational** or **sequential**. A combinational circuit is memoryless, but a sequential circuit has memory.     1. A **combinational circuit\u2019s outputs** **depend** only on the **current values of the inputs**; in other words, it combines the current input values to compute the output. For example, **a logic gate is a combinational circuit**.     2. A **sequential circuit\u2019s outputs depend** on both current and precious values of the inputs; in other words, it depends on the **input sequence**. - The functional specification of a combinational circuit **expresses the output** values **in terms of the** current **input** values. - The timing specification of a combinational circuit consists of lower and upper bounds on the delay from input to output.   \ud83d\udcd6 **Element, Node**  - Peering inside the black box, **circuits are composed of nodes and elements**. - **An element is itself a circuit** with inputs, outputs, and a specification.(Recursive) - A node is a wire, whose voltage conveys a discrete-valued variable. Nodes are classified as input, output, or internal.     - Inputs receive values from the external world.     - Outputs deliver values to the external world.     - Wires that are not inputs or outputs are called internal nodes.   \ud83d\udcd6 **The rules of combinational composition**  - A circuit is combinational if it consists of interconnected circuit elements such that     - Every circuit element is itself combinational.     - Every node of the circuit is either designated as an input to the circuit or **connects to exactly one output terminal** of a circuit element.**(!!!)**     - The circuit contains no cyclic paths: every path through the circuit visits each circuit node at most once. - The rules of combinational composition are sufficient but not strictly necessary. Certain circuits that disobey these rules are still combinational, so long as the outputs depend only on the current values of the inputs. However, determining whether oddball circuits are combinational is more difficult, so we will usually restrict ourselves to combinational composition as a way to build compositional circuits. - **Example**      ![Screenshot 2023-01-18 at 17.06.01.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-18_at_17.06.01.png)      ![Screenshot 2023-01-18 at 17.06.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-18_at_17.06.11.png)     \ud83d\udcd6 **Explanation**  - Figure 2.3 shows a combinational circuit with two inputs(A, B) and one output(Y). - In this example, the function F is specified to be OR:      $$     Y=F(A,B)=A+B     $$      The output Y is a function of the two inputs, A and B, namely       $$     Y=A\\space\\space  \\mathrm{OR}\\space\\space B     $$    \ud83d\udcd6 **Explanation**  - Figure 2.2 illustrates a circuit with three elements, E1, E2, and E3, and six nodes(A, B, C, n1, Y, Z).     - Nodes A, B and C are inputs.     - Y and Z are outputs.     - n1 is an internal node(wire) between E1 and E3."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#22-boolean-equationshow-to-write-a-boolean-expression-given-a-truth-table","title":"2.2 Boolean Equations(How to write a Boolean expression given a truth table!!!)","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#221-terminology","title":"2.2.1 Terminology(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - **complement**     - The complement of a variable $A\\,$is its inverse $\\overline{A}\\,$. - **literal**     - The variable or its complement is called a literal.     - For example, $A,\\overline{A},B,\\overline{B}\\,$are literals. - **True form and complementary form**     - We call $A\\,$the true form of the variable and $\\overline{A}\\,$the complementary form.     - True form does not mean that $A\\,$is True, but merely that A does not have a line over it. - **The order of operations**     - The order of operations is important when interpreting Boolean equations.     - In Boolean equations, NOT has the highest precedence, followed by AND, then OR.     - Just as in ordinary equations, products are preforms before sums.     - $\\overline{A}B+BC\\overline{D}=((\\overline{A})B)+(BC{(\\overline{D})})$  - **Product or implicant**     - The **AND** of one or more literals is called a product or an implicant.     - $A\\overline{B},A\\overline{B}\\overline{C},\\,$and $B\\,$are all implicants for a function of three variables. - **minterm**     - A **minterm** is a **product** **involving all the inputs** to the function.     - $A\\overline{B}\\overline{C}\\,$is a minterm for a function of the three variables $A,B,\\,$and $C,\\,$but $\\overline{A}B\\,$is not, because it does not involve $C\\,$. - **Sum**     - The **OR** of one or more literals is called a sum. - **maxterm**     - A **maxterm** is a **sum** **involving all of the inputs** to the function.     - $A+\\overline{B}+\\overline{C}\\,$is a maxterm for a function of the three variables $A,B,\\,$and $C\\,$."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#222-sum-of-products-form","title":"2.2.2 Sum-of-Products Form(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - A truth table of $N\\,$inputs contains $2^N\\,$rows, one for each possible value of the inputs. - Each row in a truth table is associated with a minterm that is TRUE for that row. - The minterm for the first row is $\\overline{A}\\,\\overline{B}\\,$because $\\overline{A}\\,\\overline{B}\\,$is TRUE when $A=0,B=0\\,$. - The minterms are numbered starting with $0$; the top row corresponds to minterm $0,\\,$$m_0,\\,$the next row to minterm $1,\\,$$m_1,\\,$and so on.  ![Screenshot 2023-01-20 at 11.07.32.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_11.07.32.png)  ![Screenshot 2023-01-20 at 11.08.46.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_11.08.46.png)  - We can write a Boolean equation for any truth table by **summing each of the minterms for which the output, $Y$, is TRUE**. - For Figure 2.8, $Y=\\overline{A}B\\,$. For Figure 2.9, $Y=\\overline{A}B+AB\\,$. - This is called the sum-of-products canonical form(standard form) of a function because it is sum(OR) of products(ANDs forming minterms). - The sum-of-products canonical form can also be written in sigma notation using the summation symbol, $\\Sigma\\,$. With this notation, the function from Figure 2.9 would be written as      $$     Y=F(A,B)=\\Sigma(m_1,m_3)=\\Sigma(1,3)     $$  - **\u6bcf\u4e2a\u6700\u5c0f\u9879\u62101\u7684\u65b9\u6cd5\u53ea\u6709\u4e00\u79cd\uff0c\u56e0\u6b64\u4e3a\u4e86\u6700\u7ec8\u7ed3\u679c\u662f1\uff0c\u5fc5\u987b\u4f7f\u7528\u6216\u8fde\u63a5\u5404\u4e2a\u6700\u5c0f\u9879\u3002** - **Sum-of-products produces a shorter equation when the output(Y) is TRUE on only a few rows of a truth table; product-of-sums is simpler when the output(Y) is FALSE on only a few rows of a truth table.** - **Example**       ![Screenshot 2023-01-20 at 11.19.53.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_11.19.53.png)      ![Screenshot 2023-01-20 at 11.24.34.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_11.24.34.png)      ![Screenshot 2023-01-20 at 11.20.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_11.20.11.png)      ![Screenshot 2023-01-20 at 11.19.39.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_11.19.39.png)      ![Screenshot 2023-01-20 at 11.24.01.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_11.24.01.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#223-product-of-sums-form","title":"2.2.3 Product-of-Sums Form(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - An alternative way of expressing Boolean functions is the product-of-sums canonical form(standard form). - Each row of the truth table corresponds to a maxterm that is FALSE for that row. - For example, the maxterm for the first row of a two-input truth table is $(A+B)\\,$because $(A+B)\\,$is FALSE when $A=0,B=0\\,$. - We can write a Boolean equation for any circuit directly from the truth table as the **AND of each of the maxterms** for which **the output is FALSE**. - The product-of-sums canonical form can also be written in pi notation using the product simple, $\\Pi$. - Similarly, a Boolean equation for Ben\u2019s picnic from Figure 2.10 can be written in product-of-sums form by circling the three rows of $0$\u2019s to obtain      $$     E=(A+\\overline{R})(\\overline{A}+R)(\\overline{A}+\\overline{R})     $$   ![Screenshot 2023-01-20 at 11.36.50.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_11.36.50.png)  - **\u6bcf\u4e2a\u6700\u5927\u9879\u62100\u7684\u65b9\u6cd5\u53ea\u6709\u4e00\u79cd\uff0c\u56e0\u6b64\u4e3a\u4e86\u6700\u7ec8\u7ed3\u679c\u662f0\uff0c\u5fc5\u987b\u4f7f\u7528\u548c\u8fde\u63a5\u5404\u4e2a\u6700\u5927\u9879\u3002** - **Sum-of-products produces a shorter equation when the output(Y) is TRUE on only a few rows of a truth table; product-of-sums is simpler when the output(Y) is FALSE on only a few rows of a truth table.**"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#23-boolean-algebrato-simplify-boolean-equations","title":"2.3 Boolean Algebra(To simplify Boolean equations!!!)","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#230-background","title":"2.3.0 Background","text":"\ud83d\udcd6 **Background**  - In the previous section, we learned how to write a Boolean expression given a truth table. - However, the expression does not necessarily lead to the simplest set of logic gates. - Just as you use algebra to simplify mathematical equations, you can use Boolean algebra to simplify Boolean equations. - The rules of Boolean algebra are much like those of ordinary algebra but are in some cases simpler, because variables have only two possible values, 0 or 1.  - Boolean algebra is based on a set of axioms that we assume are correct. - **Axions are unprovable** in the sense that a definition cannot be proved. From these axioms, we prove all the theorems of Boolean algebra. **These theorems have great practical significance, because they teach us how to simplify logic to produce smaller and less costly circuits**. - Axioms and theorems of Boolean algebra obey the principle of duality. If the symbols 0 and 1 **and** the operators $\\bullet$(AND) and $+$(OR) are interchanged, the statement will still be correct. We use the prime symbol($\\,^\\prime\\,$) to denote the dual. of a statement  ![Screenshot 2023-01-20 at 12.00.23.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_12.00.23.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#231-axioms","title":"2.3.1 Axioms","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#232-theorems-of-one-variable","title":"2.3.2 Theorems of One Variable","text":"\ud83d\udcd6 **Important takeaways**  ![Screenshot 2023-01-20 at 13.16.58.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_13.16.58.png)  ![Screenshot 2023-01-20 at 13.17.10.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_13.17.10.png)  ![Screenshot 2023-01-20 at 13.17.19.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_13.17.19.png)  ![Screenshot 2023-01-20 at 13.17.35.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_13.17.35.png)  ![Screenshot 2023-01-20 at 13.17.55.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_13.17.55.png)  ![Screenshot 2023-01-20 at 13.17.47.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_13.17.47.png)  - **The identity theorem, T1**     - T1 means that if one input of a two-input AND gate is always 1, we can remove the AND gate and replace it with a wire connected to the variable input(B). Likewise, T1\u2019 means that if one input of a two-input OR gate is always 0, we can replace the OR gate with a wire connected to B.     - In general, gates cost money, power, and delay, so replacing a gate with a wire is beneficial. - **The null element theorem, T2**     - 0 is called the null element for the AND operation.     - 1 is the null element for the OR operation. - **Idempotency, T3**     - idem(same), and potent(power).     - A variable AND itself is equal to just itself.     - Idempotency again permits replacing a gate with a wire. - **Involution, T4**     - Complementing a variable twice results in the original variable.     - Two inverters in series logically cancel each other out and are logically equivalent to a wire. - **The complement theorem, T5**     - A variable AND its complement is 0.     - A variable OR its complement is 1."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#233-theorems-of-several-variables","title":"2.3.3 Theorems of Several Variables","text":"\ud83d\udcd6 **Important takeaways**  ![Screenshot 2023-01-20 at 13.40.28.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_13.40.28.png)  - **Covering, T9**      $$     \\begin{align*}B\\bullet(B+C)&amp;=(B+0)\\bullet(B+C)\\\\&amp;=B+(0\\bullet C)\\\\&amp;=B+0\\\\&amp;=B\\end{align*}     $$      $$     \\begin{align*}B+(B\\bullet C)&amp;=(B\\bullet1)+(B\\bullet C)\\\\&amp;=B\\bullet(1+C)\\\\&amp;=B\\bullet 1\\\\&amp;=B\\end{align*}     $$   - **Combining, T10**      $$     \\begin{align*}(B\\bullet C)+(B\\bullet \\overline{C})&amp;=B\\bullet(C+\\overline{C})\\\\&amp;=B\\bullet 1\\\\&amp;=B\\end{align*}     $$      $$     \\begin{align*}(B+C)\\bullet(B+ \\overline{C})&amp;=B+(C\\bullet\\overline{C})\\\\&amp;=B+0\\\\&amp;=B\\end{align*}     $$  - **Consensus, T11**      $$     \\begin{align*}(B\\bullet C)+(\\overline{B}\\bullet D)+(C\\bullet D)&amp;=(B\\bullet C)+(\\overline{B}\\bullet D)+(B+\\overline{B})\\bullet(C\\bullet D)\\\\&amp;=B\\bullet C+\\overline{B}\\bullet D+B\\bullet C\\bullet D+\\overline{B}\\bullet C\\bullet D\\\\&amp;=B\\bullet C\\bullet(1+D)+\\overline{B}\\bullet D\\bullet(1+C)\\\\&amp;=B\\bullet C+\\overline{B}\\bullet D\\end{align*}     $$      $$     \\begin{align*}(B+C)\\bullet(\\overline{B}+ D)\\bullet(C+D)&amp;=(B+C)\\bullet(\\overline{B}+ D)\\bullet\\Big((B\\bullet \\overline{B})+(C+D)\\Big)\\\\&amp;=(B+C)\\bullet(\\overline{B}+ D)\\bullet(B+C+D)\\bullet(\\overline{B}+C+D)\\\\&amp;=\\Big((B+C)+(0\\bullet D)\\Big)\\bullet\\Big((\\overline{B}+D)+(0\\bullet C)\\Big)\\\\&amp;=(B+C)\\bullet(B+D)\\end{align*}     $$  - **De Morgan\u2019s Theorem, T12**       &gt; The complement of the product of all the terms is equal to the sum of the complement of each term     &gt;      1. If $x\\in\\overline{B_0\\bullet B_1\\bullet B_2\\cdots}\\,$, then $x\\notin B_0\\bullet B_1\\bullet B_2\\cdots\\,$, then $x\\notin B_0\\,\\text{or}\\,x\\notin B_1\\,\\text{or}\\,x\\notin B_2\\,\\text{or}\\cdots\\,$, then $\\,x\\in \\overline{B_0}\\,\\text{or}\\,x\\in \\overline{B_1}\\,\\text{or}\\,x\\in \\overline{B_2}\\,\\text{or}\\cdots\\,$.     2. Thus, $\\,x\\in \\overline{B_0}+\\overline{B_1}+\\overline{B_2}+\\cdots\\,$.     3. If $x\\in \\overline{B_0}+\\overline{B_1}+\\overline{B_2}+\\cdots\\,$, then $\\,x\\in \\overline{B_0}\\,\\text{or}\\,x\\in \\overline{B_1}\\,\\text{or}\\,x\\in \\overline{B_2}\\,\\text{or}\\cdots\\,$, then $x\\notin B_0\\,\\text{or}\\,x\\notin B_1\\,\\text{or}\\,x\\notin B_2\\,\\text{or}\\cdots\\,$, then $x\\notin B_0\\bullet B_1\\bullet B_2\\cdots$.     4. Thus, $x\\in \\overline{B_0\\bullet B_1\\bullet B_2\\cdots}\\,$.      &gt; The complement of the sum of all the terms is equal to the product of the complement of each term.     &gt;      1. If $x\\in\\overline{B_0+ B_1+ B_2\\cdots}\\,$, then $x\\notin B_0+B_1+B_2+\\cdots\\,$, then $x\\notin B_0 \\,\\text{and}\\,x\\notin B_1 \\,\\text{and}\\,x\\notin B_2 \\,\\text{and}\\cdots\\,$, then $x\\in \\overline{B_0} \\,\\text{and}\\,x\\in \\overline{B_1} \\,\\text{and}\\,x\\in \\overline{B_2} \\,\\text{and}\\cdots\\,$     2. Thus $x\\in \\overline{B_0}\\bullet\\overline{B_1}\\bullet\\overline{B_2}\\cdots\\,$.     3. If $x\\in \\overline{B_0}\\bullet\\overline{B_1}\\bullet\\overline{B_2}\\cdots\\,$, then $x\\in \\overline{B_0} \\,\\text{and}\\,x\\in \\overline{B_1} \\,\\text{and}\\,x\\in \\overline{B_2} \\,\\text{and}\\cdots\\,$, then $x\\notin B_0 \\,\\text{and}\\,x\\notin B_1 \\,\\text{and}\\,x\\notin B_2 \\,\\text{and}\\cdots\\,$, then $x\\notin B_0+B_1+B_2+\\cdots\\,$     4. Thus $x\\in\\overline{B_0+ B_1+ B_2\\cdots}\\,$.      - According to De Morgan\u2019s theorem, a NAND gate is equivalent to an OR gate with inverted inputs.     - Similarly, a NOR gate is equivalent to an AND gate with inverted inputs.     - **The inversion circle is called a bubble**.     - Intuitively, you can imagine that \u201cpushing\u201d a bubble through the gate causes it to **come out at the other side** and **flips the body of the gate** from AND to OR or vice versa     - The underlying rules for bubble pushing are:         1. Pushing bubbles backward(from the output) or forward(from the inputs) changes the body of the gate from AND to OR or vice versa.         2. Pushing **a bubble** **from the output back to the inputs** puts **bubbles on all** gate **inputs**.         3. Pushing bubbles on **all gate inputs forward** **toward the output** puts **a bubble** on the **output**.      ![Screenshot 2023-01-20 at 14.37.47.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-20_at_14.37.47.png)  - **Example**      Figure 2.20 shows the truth table for a Boolean function $Y\\,$and its complement $\\overline{Y}\\,$. Using De Morgan\u2019s Theorem, derive the product-of-sums canonical form of $Y\\,$from the sum-of-products form of $\\overline{Y}\\,$.      - sum-of-products form of $\\overline{Y}\\,$:          $$         \\overline{Y}=\\overline{A}\\,\\overline{B}+\\overline{A}B         $$      - product-of-sums form of $\\overline{Y}\\,$:          $$         \\overline{Y}=(\\overline{A}+B)(\\overline{A}+\\overline{B})         $$       - sum-of-products form of $Y\\,$:          $$         Y=A\\overline{B}+AB         $$      - product-of-sums form of $Y\\,$:          $$         Y=(A+B)(A+\\overline{B})         $$      - De Morgan\u2019s Theorem:          $$         Y=\\overline{\\overline{Y}}=\\overline{\\overline{A}\\,\\overline{B}+\\overline{A}B}=\\overline{\\overline{A}\\,\\overline{B}}\\,\\overline{\\overline{A}B}=(A+B)(A+\\overline{B})         $$          $$         Y=\\overline{\\overline{Y}}=\\overline{(\\overline{A}+B)(\\overline{A}+\\overline{B})}=\\overline{\\overline{A}+B}+\\overline{\\overline{A}+\\overline{B}}=A\\overline{B}+AB         $$       ![Screenshot 2023-01-21 at 09.06.39.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_09.06.39.png)      ![Screenshot 2023-01-21 at 09.06.48.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_09.06.48.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#234-the-truth-behind-it-all","title":"2.3.4 The Truth Behind It All","text":"\ud83d\udcd6 **Important takeaways**  - In Boolean algebra, proofs of theorems with a finite number of variables are easy: just show that the theorem holds for all possible values of these variables. **This method is called perfect induction and can be done with a truth table**. - **Example**       ![Screenshot 2023-01-21 at 09.24.25.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_09.24.25.png)      ![Screenshot 2023-01-21 at 09.26.09.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_09.26.09.png)      ![Screenshot 2023-01-21 at 09.25.05.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_09.25.05.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#235-simplifying-equations","title":"2.3.5 Simplifying Equations","text":"\ud83d\udcd6 **Important takeaways**  - The theorems of Boolean algebra help us simplify Boolean equations. In general, multiple steps may be necessary to simplify more complex equations. - The basic principle of simplifying sum-of-products equations is to combine terms using the relationship $PA+P\\overline{A}=P(A+\\overline{A})=P\\bullet1=P\\,$, where $P\\,$may be any implicant. - We define an equation in sum-of-products form to be minimized if it uses the fewest possible implicants. - If there are several equations with the same number of implicants, the minimal one is the one with the fewest literals. - An implicant is called a prime implicant if it cannot be combined with any other implicants in the equation to form a new implicant with fewer literals. - The implicants in a minimal equation must all be prime implicants. Otherwise, they could be combined to reduce the number of literals.  ![Screenshot 2023-01-21 at 09.40.41.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_09.40.41.png)  ![Screenshot 2023-01-21 at 09.41.04.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_09.41.04.png)  ![Screenshot 2023-01-21 at 09.41.18.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_09.41.18.png)  - Completely simplifying a Boolean equation with the theorems of Boolean algebra can take some trial and error. Section 2.7 describes a methodical technique called Karnaugh maps that make the process easier. - Why bother simplifying a Boolean equation if it remains logically equivalent? **Simplifying reduces the number of gates used to physically implement the function, thus making it smaller, cheaper, and possibly faster**."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#24-from-logic-to-gates","title":"2.4 From Logic To Gates","text":"\ud83d\udcd6 **Important takeaways**  - A schematic is a diagram of a digital circuit showing the elements and the wires that connect them together.  - By drawing schematics in a consistent fashion, we make them easier to read and debug. We will generally obey the following guidelines:     - Inputs are on the left(or top) side of a schematic.     - Outputs are on the right(or bottom) side of a schematic.     - Whenever possible, gates should flow from left to right.     - Straight wires are better to use than wires with multiple corners(jagged wires waste mental effort following the wire rather than thinking of what the circuit does).     - Wires always connect at a T junction.     - A dot where wires cross indicates a connection between the wires.     - Wires crossing without a dot make no connection. - Any Boolean equation in sum-of-products form can be drawn as a schematic in a systematic way similar to Figure 2.23.     - First, draw columns for the inputs. Place inverters in adjacent columns to provide the complement inputs if necessary.     - Draw rows of AND gates for each of the minterms.     - Then, for each output, draw an OR gate connected to the minterms related to that output.      &gt; This style is called a programmable logic array(PLA) because the inverters, AND gates, and OR gates are arrayed in a systematic fashion.     &gt;  - We can reduce the number of gates even further(albeit by a single inverter) by taking advantage of inverting gates.     - Observe that $\\overline{B}\\,\\overline{C}\\,$is an AND with inverted inputs. Figure 2.26 shows a schematic using this optimization to elimininate the inverter on $C\\,$.     - Recall that by De Morgans\u2019s theorem the AND with inverted inputs is equivalent to a NOR gate(pushing the bubbles).          $$         \\overline{A}\\,\\overline{B}=\\overline{A+B}\\space(\\mathrm{NOR})         $$      - Depending on the implementation technology, it may be cheaper to use the fewest gates or to use certain types of gates in preference to others.     - For example, NANDs and NORs are preferred over ANDs and ORs in CMOS implementations. - **Example: Multiple-output circuits(four-input priority circuit)**      ![Screenshot 2023-01-21 at 11.43.20.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_11.43.20.png)      - **Slower approach**         - Write each output in sum-of-products form and reduce the equations using Boolean algebra              $$             \\begin{align*}Y_3&amp;=A_3\\overline{A_2}\\,\\overline{A_1}\\,\\overline{A_0}+A_3\\overline{A_2}\\,\\overline{A_1}A_0+A_3\\overline{A_2}A_1\\overline{A_0}+A_3\\overline{A_2}A_1A_0\\\\&amp;+A_3A_2\\overline{A_1}\\,\\overline{A_0}+A_3A_2\\overline{A_1}A_0+A_3A_2A_1\\overline{A_0}+A_3A_2A_1A_0\\\\&amp;=A_3\\overline{A_2}\\,\\overline{A_1}+A_3\\overline{A_2}A_1+A_3A_2\\overline{A_1}+A_3A_2A_1\\\\&amp;=A_3\\overline{A_2}+A_3A_2\\\\&amp;=A_3\\end{align*}             $$              $$             \\begin{align*}Y_2&amp;=\\overline{A_3}A_2\\overline{A_1}\\,\\overline{A_0}+\\overline{A_3}A_2\\overline{A_1}A_0+\\overline{A_3}A_2A_1\\overline{A_0}+\\overline{A_3}A_2A_1A_0\\\\&amp;=\\overline{A_3}A_2\\overline{A_1}+\\overline{A_3}A_2A_1\\\\&amp;=\\overline{A_3}A_2\\end{align*}             $$              $$             \\begin{align*}Y_1&amp;=\\overline{A_3}\\,\\overline{A_2}A_1\\overline{A_0}+\\overline{A_3}\\,\\overline{A_2}A_1A_0\\\\&amp;=\\overline{A_3}\\,\\overline{A_2}A_1\\end{align*}             $$              $$             Y_0=\\overline{A_3}\\,\\overline{A_2}\\,\\overline{A_1}A_0             $$      - **Faster approach**         - The simplified equations are clear **by inspection from the functional description**(and the truth table): $Y_3\\,$is TRUE whenever $A_3\\,$is asserted, so $Y_3=A_3\\,$. $Y_2\\,$is TRUE if $A_2\\,$is asserted and $A_3\\,$is not asserted, so $Y_2=\\overline{A_3}A_2\\,$. $Y_1\\,$is TRUE if $A_1\\,$is asserted and neither of the higher priority inputs is asserted: $Y_1=\\overline{A_3}\\,\\overline{A_2}A_1\\,$. And $Y_0\\,$is TRUE whenever $A_0\\,$and no other input is asserted: $Y_0=\\overline{A_3}\\,\\overline{A_2}\\,\\overline{A_1}A_0\\,$.         - An experienced designer can often implement a logic circuit by inspection. Given a clear specification, simply turn the words into equations and the equations into gates.         - Notice that if $A_3\\,$is asserted in the priority circuit, the outputs don\u2019t care what the other inputs are. We use the symbol $\\mathrm{X}\\,$to describe inputs that the outputs doesn\u2019t care about.         - Figure 2.29 shows that the four-input priority circuit truth table becomes much smaller with don\u2019t cares. From this truth table, we can easily read the Boolean equations in sum-of-products form **by ignoring inputs with X\u2019s**. Don\u2019t cares can also appear in truth table outputs.  ![Screenshot 2023-01-21 at 10.01.09.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_10.01.09.png)  ![Screenshot 2023-01-21 at 10.02.08.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_10.02.08.png)  ![Screenshot 2023-01-21 at 10.01.41.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_10.01.41.png)  ![Screenshot 2023-01-21 at 11.43.55.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_11.43.55.png)  ![Screenshot 2023-01-21 at 11.44.39.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_11.44.39.png)  ![Screenshot 2023-01-21 at 11.45.17.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_11.45.17.png)  ![Screenshot 2023-01-21 at 11.45.45.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_11.45.45.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#25-multilevel-combinational-logic","title":"2.5 Multilevel Combinational Logic(!!!)","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#250-background","title":"2.5.0 Background","text":"\ud83d\udcd6 **Background**  Logic in sum-of-products form is called two-level logic because it consists of literals connected to a level of AND gates connected to a level of OR gates. **Designers often** build circuits **with more than two levels of logic gates**. These **multilevel combinational circuits** **may use less hardware than their two-level counterparts**. **Bubble pushing** is especially helpful in **analyzing and designing multilevel circuits**."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#251-hardware-reduction","title":"2.5.1 Hardware Reduction(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - Some logic functions require an **enormous amount of hardware** when **built using two-level logic**. - A notable example is the XOR function of multiple variables. - **Example: building a three-input XOR** using the two-level techniques we have studied so far.      ![Screenshot 2023-01-21 at 13.37.08.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_13.37.08.png)      $$     Y=\\overline{A}\\,\\overline{B}C+\\overline{A}B\\overline{C}+A\\overline{B}\\,\\overline{C}+ABC     $$      Unfortunately, there is no way to simplify this equation into fewer implicants.   - **Smarter Approach**      On the other hand, $A\\oplus B\\oplus C=(A\\oplus B)\\oplus C\\,$.      - Truth table(for reference)           | $A$ | $B$ | $C$ | $A\\oplus B\\oplus C$ | $(A\\oplus B)\\oplus C$ |         | --- | --- | --- | --- | --- |         | 0 | 0 | 0 | 0 | 0 |         | 0 | 0 | 1 | 1 | 1 |         | 0 | 1 | 0 | 1 | 1 |         | 0 | 1 | 1 | 0 | 0 |         | 1 | 0 | 0 | 1 | 1 |         | 1 | 0 | 1 | 0 | 0 |         | 1 | 1 | 0 | 0 | 0 |         | 1 | 1 | 1 | 1 | 1 |      Therefore, the three-input XOR can be built out of a cascade of two-input XORs.      Similarly, an eight-input XOR would require 128 eight-input AND gates and one 128-input OR gate for a two-level sum-of-products implementation.      A much better option is to use a tree of two-input XOR gates.      $$     A\\oplus B\\oplus C\\oplus D\\oplus E\\oplus F\\oplus G\\oplus H\\\\=((A\\oplus B)\\oplus(C\\oplus D))\\oplus((E\\oplus F)\\oplus(G\\oplus H))     $$      ![Screenshot 2023-01-21 at 13.48.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_13.48.11.png)      ![Screenshot 2023-01-21 at 13.53.54.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_13.53.54.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#252-bubble-pushing","title":"2.5.2 Bubble Pushing(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - Figure 2.33 shows a multilevel circuit whose function is not immediately clear by inspection.      ![Screenshot 2023-01-21 at 14.03.13.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_14.03.13.png)      $$     \\begin{align*}Y&amp;=\\overline{\\overline{\\overline{A+B}\\bullet C}\\bullet D}\\\\&amp;=\\overline{\\overline{\\overline{A}\\bullet \\overline{B}\\bullet C}\\bullet D}\\\\&amp;=\\overline{(A+B+\\overline{C})\\bullet D}\\\\&amp;=\\overline{A+B+\\overline{C}}+\\overline{D}\\\\&amp;=\\overline{A}\\,\\overline{B}C+\\overline{D}\\end{align*}     $$  - **Bubble pushing is a helpful way to redraw these circuits so that the bubbles cancel out and the function can be more easily determined**. - **(REVIEW!!!)**The underlying rules for bubble pushing are:     1. Pushing bubbles backward(from the output) or forward(from the inputs) **changes the body of the gate from AND to OR or vice versa**.     2. Pushing **a bubble** **from the output back to the inputs** puts **bubbles on all** gate **inputs**.     3. Pushing bubbles on **all gate inputs forward** **toward the output** puts **a bubble** on the **output**. - The guidelines or bubble pushing are as follows:     - **Begin at the output of the circuit and work toward the inputs**.     - **Push any bubbles on the final output** **back towards the inputs** so that you can read an equation in terms of the output($\\,Y$), instead of the complement of the output ($\\,\\overline{Y}$).     - Working backward, draw each gate in a form so that bubbles cancel. If the current gate has an input bubble, draw the preceding gate(the gate before) with an output bubble. If the current gate does not have an input bubble, draw the preceding gate without an output bubble.  ![Screenshot 2023-01-21 at 14.16.59.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_14.16.59.png)  ![Screenshot 2023-01-21 at 14.54.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_14.54.11.png)  ![Screenshot 2023-01-21 at 14.54.44.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_14.54.44.png)  ![Screenshot 2023-01-21 at 15.08.05.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_15.08.05.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#26-xs-and-zs-oh-my","title":"2.6 X\u2019s and Z\u2019s, Oh My","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#261-illegal-value-x","title":"2.6.1 Illegal Value: X","text":"\ud83d\udcd6 **Important takeaways**  - The **symbol X** indicates that **the circuit node has an unknown or illegal value**. - This commonly happens if it is being driven to both 0 and 1 at the same time. - Figure 2.39 shows a case where node Y is driven both HIGH and LOW. This situation, called contention, is considered to be an error and must be avoided. - Contention can cause large amounts to power to flow between the fighting gates, resulting in the circuit getting hot and possibly damaged. - X values are also sometimes used by circuit simulators to indicate an uninitialized value. For example, if you forget to specify the value of an input, the simulator may assume it is an X to warn you of the problem. - Digital designers also use the symbol X to indicate \u201cdon\u2019t care\u201d values in truth tables. Be sure not to mix up the two meanings. - When X appears in a truth table, it indicates that the value of the variable in the truth table is unimportant(can be either 0 or 1). When X appears in a circuit, it means that the circuit node has an unknown or illegal value.  ![Screenshot 2023-01-21 at 15.17.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_15.17.36.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#262-floating-value-z","title":"2.6.2 Floating Value: Z","text":"\ud83d\udcd6 **Important takeaways**  - The **symbol Z** indicates that a node is being driven neither HIGH nor LOW. - The node is said to be floating, high impedance, or high Z. - A typical misconception is that a floating or undriven node is the same as a logic 0. **In reality, a floating node might be 0, might be 1, or might be at some voltage in between, depending on the history of the system**. - The tristate buffer, shown in Figure 2.40, has three possible output states: HIGH(1), LOW(0), and floating(Z). The tristate buffer has an input A, output Y, and enable E. When the enable is TRUE, the tristate buffer acts as a simple buffer, transferring the input value to the output. When the enable is FALSE, the output is allowed to float(Z). - The tristate buffer in Figure 2.40 has an active high enable. That is, when the enable is HIGH(1), the buffer is enabled. - Figure 2.41 shows a tristate buffer with an active low enable. When the enable is LOW(0), the buffer is enabled. - We show that the signal is active low by putting a bubble on its input wire. We often indicate an active low input by drawing a bar over its name, $\\overline{E}\\,$, or appending the letters \u201cb\u201d or \u201cbar\u201d after its name, Eb or Ebar. - Tristate buffers are commonly used on busses that connect multiple chips. For example, a microprocessor, a video controller, and an Ethernet controller might all need to communicate with the memory system in a personal computer. Each chip can connect to a shared memory bus using tristate buffers, as shown in Figure 2.42(en1, en2, en3, en4). Only one chip at a time is allowed to assert its enable signal to drive a value onto the bus. The other chips must produce floating inputs **so that they do not cause contention with the chip talking to the memory**. Any chip can **read** the information from the shared bus at any time. - Such tristate busses were once common. However, in modern computers, higher speeds are possible with point-to-point links, in which chips are connected to each other directly rather than over a shared bus.  ![Screenshot 2023-01-21 at 15.28.26.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_15.28.26.png)  ![Screenshot 2023-01-21 at 15.28.52.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_15.28.52.png)  ![Screenshot 2023-01-21 at 15.32.21.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_15.32.21.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#27-karnaugh-maps","title":"2.7 Karnaugh Maps(!!!)","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#270-background","title":"2.7.0 Background","text":"\ud83d\udcd6 **Background**  - After working through several minimizations of Boolean equations using Boolean algebra, you will realize that, if you are not careful, you sometimes end up with a completely different equation instead of a simplified equation. - Karnaugh maps(K-maps) are a graphical method for simplifying equations. They were invented in 1953 by Maurice Karnaugh, a telecommunications engineer at Bell Labs. - **K-maps work well for problems with up to four variables**. More important, they give insight into manipulating Boolean equations. - **Gray code**     - You may have noticed that the $A\\,$and $B\\,$combinations in the top row are in peculiar order: 00, 01, 11, 10. This order is called a Gray code.     - It differs from ordinary binary order: $(00,01,10,11)\\,$in that **adjacent entries differ only in a single variable**. Ordinary binary order doesn\u2019t have this property($\\,01\\,$and $10\\,$). Hence, writing the combinations in binary order would not have produced our desired property of adjacent squares differing only in one variable.     - Gray codes were patented by Frank Gray, a Bell Labs reseacher, in 1953. They were especially useful in mechanical encoders because a slight misalignment causes an error in only one bit.     - Gray codes generalize to any number of bits. For example, a 3-bit Gray code sequence is:            $$         000,001,011,010,110,111,101,100         $$   ![Screenshot 2023-01-21 at 17.19.59.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_17.19.59.png)  - Figure 2.43 shows the truth table and K-map for a three-input(A, B, C) function. **The top row of the K-map** gives the four possible values for the A and B inputs. **The left column** gives the two possible values for the C input. - Each square in the K-map corresponds to a row in the truth table and contains the value of the output Y for that row. For example, the top left square corresponds to the first row in the truth table and indicates that the output value $Y=1\\,$when $ABC=000\\,$. - Just like each row in a truth table, each square in a K-map represents a single minterm. For the purpose of explanation, Figure 2.43(c) shows the minterm corresponding to each square in the K-map. - Each square, or minterm, **differs from an adjacent square** by **a change** in **a single variable**. This means that adjacent squares share all the same literals except one, which appears in true form in one square and in complementary form in the other. For example, the squares representing the minterm $\\overline{A}\\,\\overline{B}\\,\\overline{C}\\,$ and $\\overline{A}\\,\\overline{B}C\\,$are adjacent and differ only in the variable C. - **Wrap around**     - **The K-map also \u201cwraps around.\u201d The squares on the far right are effectively adjacent to the squares on the far left, in that they differ only in one variable, $A$**.     - In other words, you could take the map and roll it into a cylinder, then join the ends of the cylinder to form a torus(i.e., a donut), and still guarantee that adjacent squares would differ only in one variable."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#271-circular-thinking","title":"2.7.1 Circular thinking","text":"\ud83d\udcd6 **Important takeaways**  - In the K-map in Figure 2.43, only two minterms are present in the equation, $\\overline{A}\\,\\overline{B}\\,\\overline{C}\\,$ and $\\overline{A}\\,\\overline{B}C\\,$, as indicated by the 1\u2019s in the left column. Reading the minterms from the K-map is exactly equivalent to reading equations in sum-of-products form directly from the truth table. - As before, we can use Boolean algebra to minimize equations in sum-of-products form.      $$     Y=\\overline{A}\\,\\overline{B}\\,\\overline{C}+\\overline{A}\\,\\overline{B}C=\\overline{A}\\,\\overline{B}(\\overline{C}+C)=\\overline{A}\\,\\overline{B}     $$  - K-maps help us do this simplification graphically by circling 1\u2019s in adjacent squares, as shown in Figure 2.44. For each circle, we write the corresponding implicant. - Variables whose **true and complementary forms are both in the circle** are **excluded from the implicant**. In this case, the variable $C\\,$has both its true form(1) and its complementary form(0) in the circle, so we do not include it in the implicant. - In other words, $Y\\,$is true when $A=B=0\\,$, independent of $C\\,$. So the implicant is $\\overline{A}\\,\\overline{B}\\,$. The K-map gives the same answer we reached using Boolean algebra.  ![Screenshot 2023-01-21 at 17.19.59.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_17.19.59%201.png)  ![Screenshot 2023-01-21 at 23.36.50.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_23.36.50.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#272-logic-minimization-with-k-maps","title":"2.7.2 Logic Minimization with K-Maps(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - K-maps provide an easy visual way to minimize logic. Simply circle all the rectangular blocks of 1\u2019s in the map, using the fewest possible number of circles. Each circle should be as large as possible. Then read off the implicants that were circled. - More formally, recall that a Boolean equation is minimized when it is written as sum of the fewest number of prime implicants. Each circle on the K-map represents an implicant. The largest possible circles are prime implicants. - For example, in the K-map of Figure 2.44, $\\overline{A}\\,\\overline{B}\\,\\overline{C}\\,$ and $\\overline{A}\\,\\overline{B}C\\,$are implicants, but not prime implicants. Only $\\overline{A}\\,\\overline{B}\\,$is a prime implicant in that K-map. - **Rules for finding a minimized equation from a K-map are as follows:**     - Use **the fewest circles** necessary to cover all the 1\u2019s.     - All the squares in each circle must contain 1\u2019s.     - **Each circle** must span a rectangular block **that is a power of 2**(i.e., 1, 2, or 4) squares **in each direction**.     - **Each circle should be as large as possible**.     - A circle **may wrap around the edges** of the K-map.     - **A 1 in a K-map may be circled multiple times** if doing so allows fewer circles to be used. - **Example 2.9: Minimization of a three-variable function using a K-map**     - Circle the 1\u2019s in the K-map using a few circles as possible, as shown in Figure 2.46.     - Notice how the circle covering four squares wraps around the sides of the K-map.     - Notice how the top-right square(minterm) is covered twice to make the prime implicant circles as large as possible.     - As we saw with Boolean algebra techniques, this is equivalent to sharing a minterm to reduce the size of the implicant.(Idempotency)          ![Screenshot 2023-01-22 at 00.00.35.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_00.00.35.png)  - **Example 2.10: Seven-segment display decoder**      **Key points:**      1. Remember that adjacent squares may differ in only a single variable, so we label the rows and columns in Gray code order: 00, 01, 11, 10. Be careful to also remember this ordering when entering the output values into the squares.     2. Next, circle the **prime implicants**. Use the **fewest number of circles** necessary to **cover all the 1\u2019s**. A circle can **wrap around the edges**(vertical and horizontal), and a 1 may be circled more than once.     3. Note that **the minimal set of prime implicants is not unique**. For example, the 0000 entry in the $S_a\\,$K-map was circled along with the 1000 entry to produce the $\\overline{D_2}\\,\\overline{D_1}\\,\\overline{D_0}\\,$minterm. The circled would have included the 0010 entry instead, producing a $\\overline{D_3}\\,\\overline{D_2}\\,\\overline{D_0}\\,$minterm, as shown with dashed lines in Figure 2.51.     4. Figure 2.52 illustrates a common error in which a **nonprime implicant was chosen to cover the 1 in the upper left corner**. This minterm, $\\overline{D_3}\\,\\overline{D_2}\\,\\overline{D_1}\\,\\overline{D_0}\\,$, gives a sum-of-products equation that is not minimal. The minterm could have been combined with either of the adjacent ones to form a larger circle, as was done in the previous two figures.      ![Screenshot 2023-01-22 at 09.52.05.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_09.52.05.png)      ![Screenshot 2023-01-22 at 10.01.46.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_10.01.46.png)   ![Screenshot 2023-01-21 at 23.36.50.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_23.36.50%201.png)  ![Screenshot 2023-01-21 at 23.55.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_23.55.11.png)  ![Screenshot 2023-01-21 at 23.55.51.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_23.55.51.png)  ![Screenshot 2023-01-21 at 23.54.35.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-21_at_23.54.35.png)  ![Screenshot 2023-01-22 at 10.02.00.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_10.02.00.png)  ![Screenshot 2023-01-22 at 10.02.20.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_10.02.20.png)  ![Screenshot 2023-01-22 at 10.02.35.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_10.02.35.png)  ![Screenshot 2023-01-22 at 10.05.46.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_10.05.46.png)  ![Screenshot 2023-01-22 at 10.02.54.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_10.02.54.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#273-dont-cares","title":"2.7.3 Don\u2019t cares","text":"\ud83d\udcd6 **Important takeaways**  - Recall that \u201cdon\u2019t care\u201d entries for truth table inputs were introduced in Section 2.4 to reduce the number of rows in the table when some variables do not affect the output. They are indicated by the symbol X, which means that the entry can be either 0 or 1. - **Don\u2019t cares also appear in truth table outputs** where **the output value is unimportant** or **the corresponding input combination can never happen**. Such outputs can be treated as either 0\u2019s or 1\u2019s at the designer\u2019s discretion, - In a K-map, X\u2019s allow for even more logic minimization. **They can be circled if they help cover the 1\u2019s with fewer or larger circles**, but **they do not have to be circled if they are not helpful**. - Notice that in Figure 2.53(a), **the four squares in the corner are adjacent**, 0000 is adjacent to 1000 and 0010, 1000 is adjacent to 0000 and 1010, 0010 is adjacent to 0000 and 1010, 1010 is adjacent to 1000 and 0010. So these four squares can form a $2\\times2\\,$square.  ![Screenshot 2023-01-22 at 10.22.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_10.22.36.png)  ![Screenshot 2023-01-22 at 10.21.50.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_10.21.50.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#274-the-big-picture","title":"2.7.4 The Big Picture","text":"\ud83d\udcd6 **Important takeaways**  - Boolean algebra and Karnaugh maps are **two methods of logic simplification**. Ultimately, **the goal is to find a low-cost method of implementing a particular logic function**. - In modern engineering practice, computer programs called logic synthesizers produce simplified circuits from a description of the logic function, as we will see in Chapter 4. For large problems, logic synthesizers are much more efficient than humans. For small problems, human with a bit of experience can find a good solution by inspection. - Neither of the authors has ever used a Karnaugh map in real life to solve a practical problem. But the insight gained from the principles underlying Karnaugh maps is valuable. And Karnaugh maps often appear to job interviews."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#28-combinational-building-blocks","title":"2.8 Combinational Building Blocks(!!!)","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#280-background","title":"2.8.0 Background","text":"\ud83d\udcd6 **Background**  - **Combinational logic is often grouped into larger building blocks to build more complex systems**. - This is an application of **the principle of abstraction**, **hiding the unnecessary gate-level details to emphasize the function of the building block**. - We have already studied three such building blocks: full adders, priority circuits, and seven-segment display decoders. - This section introduces two more commonly used building blocks: multiplexers and decoders. - Chapter 5 covers other combinational building blocks.      ![Screenshot 2023-01-22 at 11.12.50.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.12.50.png)      ![Screenshot 2023-01-22 at 11.11.50.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.11.50.png)   ![Screenshot 2023-01-22 at 11.09.53.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.09.53.png)  ![Screenshot 2023-01-22 at 11.09.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.09.36.png)  ![Screenshot 2023-01-22 at 11.14.02.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.14.02.png)  ![Screenshot 2023-01-22 at 11.14.16.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.14.16.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#281-multiplexers","title":"2.8.1 Multiplexers(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - Multiplexers are among the most commonly used combinational circuits. - They **choose an output from among several possible inputs** **based on the value of a select signal**. - A multiplexer is sometimes affectionately called a mux. - Figure 2.54 shows the schematic and truth table for a 2:1 multiplexer with two data inputs $D_0\\,$and $D_1\\,$, a select input $S\\,$, and one output $Y\\,$. - **The multiplexer chooses between the two data inputs based on the select: if $S=0\\,$, $Y=D_0\\,$, and if $S=1\\,$, $Y=D_1\\,$. $S\\,$is also called a control signal because it controls what the multiplexer does**. - A 2:1 multiplexer can be built from sum-of-produces logic as shown in Figure 2.55. The Boolean equation for the multiplexer may be derived with a Karnaugh map or read of by inspection($Y\\,$is 1 if $S=0\\,$AND $D_0\\,$is 1 OR if $S=1\\,$AND $D_1\\,$is 1)      $$     Y=\\overline{S}D_0+SD_1=D_0\\overline{S}+D_1S     $$  - Alternatively, multiplexers can be built from tristate buffers as shown in Figure 2.56. The tristate enables are arranged such that, at all times, exactly one tristate buffer is active. When $S=0\\,$, tristate $T_0\\,$is enabled, allowing $D_0\\,$to flow to $Y\\,$. When $S=1\\,$, tristate $T_1\\,$is enabled, allowing $D_1\\,$to flow to $Y$.  ![Screenshot 2023-01-22 at 11.33.44.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.33.44.png)  ![Screenshot 2023-01-22 at 11.33.54.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.33.54.png)  &gt; Shorting together the outputs of multiple gates technically violates the rules for combinational circuits given in Section 2.1.(\u4e0d\u5141\u8bb8\u591a\u4e2a\u652f\u6d41\u5e76\u5728\u4e00\u8d77) But because exactly one of the outputs is driven at any time, this exception is allowed. &gt;   ![Screenshot 2023-01-22 at 11.34.04.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.34.04.png)  ![Screenshot 2023-01-22 at 11.34.23.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.34.23.png)  ![Screenshot 2023-01-22 at 11.52.02.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_11.52.02.png)  - **Wider Multiplexer**     - A 4:1 multiplexer has four data inputs and one output, as shown in Figure 2.57. Two select signals are needed to choose among the four data inputs. The 4:1 multiplexer can be built using sum-of-products logic, tristates, or multiple 2:1 multiplexers, as shown in Figure 2.58.     - Wider multiplexers, such as 8:1 and 16:1 multiplexers, can be built by expanding the methods shown in Figure 2.58. In general, an N:1 multiplexer needs $\\log_2N\\,$select lines. Again, the best implementation choice depends on the target technology.     - The 4:1 multiplexer chooses between the four data inputs based on the select: if $S_1=0,S_0=0,Y=D_0\\,$, and if $S_1=0,S_0=1,Y=D_1\\,$, and if $S_1=1,S_0=0,Y=D_2\\,$, and if $S_1=1,S_0=1,Y=D_3\\,$. $S_1\\,$and $S_0\\,$are two control signals because it controls what the multiplexer does.      $$     Y=D_0\\overline{S_1}\\,\\overline{S_0}+D_1\\overline{S_1}S_0+D_2S_1\\overline{S_0}+D_3S_1S_0     $$   - \u5bf9\u4e8eFigure 2.58(a)\u548c Figure 2.58(b), \u6211\u4eec\u6839\u636e\u4e0a\u9762\u7ed9\u51fa\u7684$\\,Y\\,$\u7684\u5f0f\u5b50\u4e0d\u96be\u753b\u51fa\u7535\u8def\u3002\u5bf9\u4e8eFigure 2.58(c), \u6211\u4eec\u7a0d\u4f5c\u89e3\u91ca, $S_0\\,$\u4e3a0\u65f6\uff0c$D_0,D_2\\,$\u53ef\u4ee5\u901a\u8fc7\uff0c$S_0\\,$\u4e3a1\u65f6\uff0c$D_1,D_3\\,$\u53ef\u4ee5\u901a\u8fc7\u3002$S_1\\,$\u4e3a0\u65f6\uff0c\u7ecf\u8fc7\u7b5b\u9009\u7684$D_0,D_1\\,$\u4e2d\u7684\u5e78\u5b58\u8005\u53ef\u4ee5\u901a\u8fc7\uff0c$S_1\\,$\u4e3a1\u65f6\uff0c\u7ecf\u8fc7\u7b5b\u9009\u7684$D_2,D_3\\,$\u4e2d\u7684\u5e78\u5b58\u8005\u53ef\u4ee5\u901a\u8fc7\u3002  ![Screenshot 2023-01-22 at 12.15.10.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_12.15.10.png)  - Multiplexers can be used as lookup tables to perform logic functions. Figure 2.59 shows a 4:1 multiplexer used to implement a two-input AND gate. - The inputs, A and B, serve as select lines. The multiplexer data inputs are connected to 0 or 1 according to the corresponding row of the truth table. - In general, a $2^N$-input multiplexer can be programmed to perform any N-input logic function by applying 0\u2019s and 1\u2019s to the appropriate data inputs. - By changing the data inputs, the multiplexer can be reprogrammed to perform a different function. - With a little cleverness, we can cut the multiplexer size in half, using only a $2^{N-1}$-input multiplexer to perform any $N$-input logic function. The strategy is to provide one of the literals, as well as 0\u2019s and 1\u2019s, to the multiplexer data inputs(**multiplexer logic using variable inputs**).  ![Screenshot 2023-01-22 at 14.04.16.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_14.04.16.png)  ![Screenshot 2023-01-22 at 14.14.49.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_14.14.49.png)  ![Screenshot 2023-01-22 at 14.15.03.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_14.15.03.png)  ![Screenshot 2023-01-22 at 13.50.56.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_13.50.56.png)  - \u5bf9\u4e8e\u5de6\u8fb9\u7ed9\u51fa\u7684\u8fd9\u5f20\u771f\u503c\u8868\u6765\u8bf4\uff0c\u6709\u4e24\u4e2a\u5173\u952e\u7684\u8981\u7d20\uff0c\u7b2c\u4e00\u4e2a\u662fA\u548cB\u7684\u4e0d\u540c\u7ec4\u5408\uff0c\u7b2c\u4e8c\u4e2a\u662f\u6700\u7ec8\u8f93\u51fa\u7684\u7ed3\u679c\u3002\u8fd9\u5f20\u771f\u503c\u8868\u5bf9\u5e94\u7684\u662f$\\,Y=AB\\,$\u8fd9\u4e2a\u516c\u5f0f\u3002 - \u6211\u4eec\u60f3\u7528multiplexer\u6765\u5b9e\u73b0\u8fd9\u4e2a\u516c\u5f0f\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u628aA\u548cB\u5f53\u505a\u662f\u4e24\u4e2a\u9009\u62e9\u5668selector\uff0c\u5f53\u9009\u62e9\u5668\u7684\u7ec4\u5408\u662f00\uff0c01\uff0c10\u65f6\uff0c\u6700\u7ec8\u7684\u8f93\u51fa\u7ed3\u679c\u662f0(LOW),\u56e0\u6b64\u6211\u4eec\u5bf9\u5e94\u628a00\uff0c01\uff0c10\u63a5\u5730(\u5012\u4e09\u89d2\u8868\u793a\u63a5\u5730)\uff0c\u8fd9\u6837\u5f53\u9009\u62e9\u5668\u7684\u72b6\u6001\u4e3a00\uff0c01\uff0c10\u65f6\uff0cY\u5bf9\u5e94\u7684\u662f0(LOW)\u3002 - \u540c\u65f6\u7531\u4e8e\u5f53\u9009\u62e9\u5668\u7684\u7ec4\u5408\u662f11\u7684\u65f6\u5019\uff0c\u6700\u7ec8\u7684\u8f93\u51fa\u7ed3\u679c\u662f1(HIGH)\uff0c\u56e0\u6b64\u6211\u4eec\u5bf9\u5e94\u628a11\u63a5\u7535\u6e90(\u5c0f\u7684\u6a2a\u7ebf\u8868\u793a\u63a5\u7535\u6e90)\uff0c\u8fd9\u6837\u5f53\u9009\u62e9\u5668\u7684\u72b6\u6001\u4e3a11\u65f6\uff0cY\u5bf9\u5e94\u7684\u662f1(HIGH)\u3002  ![Screenshot 2023-01-22 at 14.08.28.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_14.08.28.png)  ![Screenshot 2023-01-22 at 14.08.12.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_14.08.12.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#282-decoders","title":"2.8.2 Decoders(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - A decoder has $N\\,$inputs and $2^N\\,$outputs. It asserts exactly one of its outputs depending on the input combination. Figure 2.63 shows a 2:4 decoder. When $A_{1:0}=00$, $Y_0=1$. When $A_{1:0}=01$, $Y_1=1$. When $A_{1:0}=10$, $Y_2=1$. When $A_{1:0}=11$, $Y_3=1$. The output are called one-hot, because exactly one is \u201chot\u201d(HIGH) at a given time. - Decoders can be combined with OR gates to build logic functions. Figure 2.65 shows the two-input XNOR function using a 2:4 decoder and a single OR gate. Because each output of a decoder represents a single minterm, the function is built as the OR of all the minterms in the function. In Figure 2.65, $Y=\\overline{A\\oplus B}=\\overline{A}\\,\\overline{B}+AB\\,$.     - Given an equation $Y=\\overline{A\\oplus B}\\,$, first draw the truth table.           | $A$ | $B$ | $A\\oplus B$ | $\\overline{A\\oplus B}$ |         | --- | --- | --- | --- |         | 0 | 0 | 0 | 1 |         | 0 | 1 | 1 | 0 |         | 1 | 0 | 1 | 0 |         | 1 | 1 | 0 | 1 |     - Thus, we conclude that          $$         Y=\\overline{A\\oplus B}=\\overline{A}\\,\\overline{B}+AB\\,         $$      - We use decoders and OR gates to build logic functions. Because each output of a decoder represents a single minterm, the function is built as the OR of all the minterms in the function. - When using decoders to build logic, it is easiest to express functions as a truth table or in canonical sum-of-products form. An $N$-input function(\u6307\u7684\u662f\u516c\u5f0f\u4e2d\u81ea\u53d8\u91cf\u7684\u4e2a\u6570\uff0c\u4f8b\u5982\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\u6709\u4e24\u4e2a\u81ea\u53d8\u91cf\uff0c\u5206\u522b\u662f$A\\,$\u548c$B\\,$) with $M\\,$1\u2019s in the truth table can be built with an $N:2^N\\,$decoder and an $M$-input OR gate attached to all of the minterms containing 1\u2019s in the truth table. - This concept will be applied to the building of Read Only Memories(ROM) in Section 5.5.6  ![Screenshot 2023-01-22 at 15.28.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_15.28.11.png)  - In general, an $N:2^N\\,$decoder can be constructed from $**2^N\\,$$N$-input** AND gates that accept the various combinations of true or complementary inputs. - Each output in a decoder represents a single minterm. For example, $Y_0\\,$represents the minterm $\\overline{A_1}\\,\\overline{A_0}\\,$. This fact will be handy when using decoders with other digital building blocks.  $$ \\begin{align*}Y_3&amp;=A_1A_0\\\\Y_2&amp;=A_1\\overline{A_0}\\\\Y_1&amp;=\\overline{A_1}A_0\\\\Y_0&amp;=\\overline{A_1}\\,\\overline{A_0}\\end{align*} $$  ![Screenshot 2023-01-22 at 15.28.22.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_15.28.22.png)  ![Screenshot 2023-01-22 at 15.28.37.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_15.28.37.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#29-timing","title":"2.9 Timing","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#290-background","title":"2.9.0 Background","text":"\ud83d\udcd6 **Background**  - In previous sections, we have been concerned primarily with whether the circuit works \u2014 ideally, using the fewest gates. - However, as any seasoned circuit designer will attest, **one of the most challenging issues in circuit design is timing: making a circuit run fast**. - An output takes time to change in response to an input change. - Figure 2.66 shows the delay between an input change and the subsequent output change for a buffer. - The figure is called a timing diagram; it portrays the transient(lasting only for a short time; impermanent) response of the buffer circuit when an input changes.  ![Screenshot 2023-01-22 at 23.50.53.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-22_at_23.50.53.png)  - The transition from LOW to HIGH is called the rising edge. Similarly, the transition form HIGH to LOW(not shown in the figure) is called the falling edge. - The blue arrow indicates that the rising edge of Y is caused by the rising edge of A. - We measure delay **from the 50% point of the input signal**, A, **to the 50% point of the output signal**, Y. The 50% point is the point at which the signal is half-way(50%) between its LOW and HIGH values as it transitions."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#291-propagation-and-contamination-delay","title":"2.9.1 Propagation and Contamination Delay","text":"\ud83d\udcd6 **Important takeaways**  &gt; When designers speak of calculating the delay of a circuit, they generally are referring to the worst-case value(the propagation delay), unless it is clear otherwise from the context. &gt;  - Combinational logic is characterized by its **propagation delay** and **contamination delay**. - The propagation delay $t_{pd}\\,$is the **maximum** time from when an input changes until the output or outputs **reach their final value**. - The contamination delay $t_{cd}\\,$is the **minimum** time from when an input changes until any output **starts to change its value**.  - Figure 2.67 illustrates a buffer\u2019s propagation delay and contamination delay in blue and gray, respectively. The figure shows that A is initially either HIGH or LOW and changes to the other state at a particular time; **we are interested only in the fact that it changes, not what value it has**. In response, Y changes some time later. The arcs indicate that Y may start to change $t_{cd}\\,$after A transitions and that Y definitely settles to its new value within $t_{pd}\\,$. - Details      The underlying causes of delay in circuits include the time required to charge the capacitance in a circuit and the speed of light. $t_{pd}\\,$and $t_{cd}\\,$may be different for many reasons, including      - different rising and falling delays     - multiple inputs and outputs, some of which are faster than others     - circuits slowing down when hot and speeding up when cold  ![Screenshot 2023-01-31 at 08.05.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.05.11.png)  - Along with the factors already listed, propagation and contamination delays are also determined by the path a signal takes from input to output. Figure 2.68 shows a four-input logic circuit. - **The critical path, shown in blue, is the path from input A or B to output Y**. It is the longest, therefore the slowest, path, because the input travels through three gates to the output. This path is critical because it limits the speed at which the circuit operates. - The short path through the circuit, shown in gray, is from input D to output Y. This is the shortest, and therefore the fastest, path through the circuit, because the input travel through only a single gate to the output. - The propagation delay of a combination circuit is the sum of the propagation delays through each element on the critical path. - The contamination delay is the sum of the contamination delays through each element on the short path. - These delays are illustrated in Figure 2.69 and are described by the following equations.      $$     \\begin{align*}t_{pd}&amp;=2t_{pd\\_{\\mathrm{AND}}}+t_{pd\\_{\\mathrm{OR}}}\\\\t_{cd}&amp;=t_{cd\\_{\\mathrm{AND}}}\\end{align*}     $$      &gt; Although we are ignoring wire delay in this analysis, digital circuits are now so fast that the delay of long wires can be as important as the delay of the gates. The speed of light delay in wires is covered in Appendix A.     &gt;   ![Screenshot 2023-01-31 at 08.12.43.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.12.43.png)  ![Screenshot 2023-01-31 at 08.20.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.20.36.png)  - **Examples**       ![Screenshot 2023-01-31 at 08.27.32.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.27.32.png)      ![Screenshot 2023-01-31 at 08.27.54.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.27.54.png)      ![Screenshot 2023-01-31 at 08.44.17.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.44.17.png)      ![Screenshot 2023-01-31 at 08.44.32.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.44.32.png)      ![Screenshot 2023-01-31 at 08.44.53.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.44.53.png)      ![Screenshot 2023-01-31 at 08.45.24.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.45.24.png)      ![Screenshot 2023-01-31 at 08.45.07.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_08.45.07.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#292-glitches","title":"2.9.2 Glitches","text":"\ud83d\udcd6 **Important takeaways**  - So far we have discussed the case where a single input transition causes a single output transition. However, it is possible that **a single input transition can cause multiple output transitions**. These are called **glitches** or hazards. Although glitches usually don\u2019t cause problems, it is important to realize that they exist and recognize them when looking at timing diagrams. Figure 2.75 shows a circuit with a glitch and the Karnaugh map of the circuit.  - The Boolean equation is correctly minimized, but let\u2019s look at what happens when $A=0,C=1\\,$, and $B\\,$transitions from 1 to 0. Figure 2.76 illustrates this scenario. The short path(shown in gray) goes through two gates, the AND and OR gates. The critical path(shown in blue) goes through an inverter and two gates, the AND and OR gates. - As B transitions from 1 to 0, **n2(on the short path) falls before n1(on the critical path) can rise**. Until n1 rises, the two inputs to the OR gates are 0, and the output Y drops to 0. When n1 eventually rises, Y returns to 1. As shown in the timing diagram of Figure 2.76, **Y starts at 1 and ends at 1 but momentarily glitches to 0**. - As long as we wait for the propagation delay to elapse before we depend on the output, glitches are not a problem, because the output eventually settles to the right answer. - If we choose to, we can avoid this glitch by adding another gate to the implementation. **This is easiest to understand in terms of the K-map**. Figure 2.77 shows how an input transition on B from ABC = 001 to ABC = 011 **moves from one prime implicant circle to another**. **The transition across the boundary of two prime implicants in the K-map indicates a possible glitch**. - As we saw from the timing graph in Figure 2.76, if the circuitry implementing one of the prime implicants turns off before the circuitry of the other prime implicant can turn on, there is a glitch. - To fix this, we **add another circle that covers that prime implicant boundary**, as shown in Figure 2.78. You might recognize this as the consensus theorem, where the added term, $\\overline{A}C$, is the consensus of redundant term.      $$     \\begin{align*}Y&amp;=\\overline{A}\\,\\overline{B}+BC\\\\Y&amp;=\\overline{A}\\,\\overline{B}+BC+\\overline{A}C\\\\&amp;=\\overline{A}\\,\\overline{B}+BC+\\overline{A}\\,\\overline{B}C+\\overline{A}BC\\\\&amp;=\\overline{A}\\,\\overline{B}+\\overline{A}\\,\\overline{B}C+BC+\\overline{A}BC\\\\&amp;=\\overline{A}\\,\\overline{B}+BC\\end{align*}     $$  - Figure 2.79 shows the glitch-proof circuit. The added AND gate is highlighted in blue. Now a transition on B when $A=0\\,$and $C=1\\,$does not cause a glitch on the output, because the blue AND gate outputs 1 throughout the transition.  ![Screenshot 2023-01-31 at 09.36.14.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_09.36.14.png)  | A | B | C | Y | | --- | --- | --- | --- | | 0 | 0 | 0 | 1 | | 0 | 0 | 1 | 1 | | 0 | 1 | 0 | 0 | | 0 | 1 | 1 | 1 | | 1 | 0 | 0 | 0 | | 1 | 0 | 1 | 0 | | 1 | 1 | 0 | 0 | | 1 | 1 | 1 | 1 |  ![Screenshot 2023-01-31 at 09.43.21.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_09.43.21.png)  ![Screenshot 2023-01-31 at 10.00.19.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_10.00.19.png)  - In general, a glitch can occur when a change in a single variable crosses the boundary between two prime implicants in a K-map. We can eliminate the glitch by adding redundant implicants to the K-map to cover these boundaries. This of course comes at the cost of extra hardware. - However, **simultaneous transitions on multiple inputs can also cause glitches**. These glitches cannot be fixed by adding hardware. Because the vast majority of interesting systems have simultaneous (or near-simultaneous) transitions on multiple inputs, glitches are a fact of life in most circuits. Although we have shown how to eliminate one kind of glitch, the point if discussing glitches is not to eliminate them but to be aware that they exist. This is especially important when looking at timing diagrams on a simulator or oscilloscope."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#210-summary","title":"2.10 Summary","text":"\ud83d\udcd6 **Summary**  - A digital circuit is a module with discrete-valued inputs and outputs and a specification describing the function? and timing of the module. This chapter has focused on combinational circuits, circuits whose outputs depend only on the current values of the inputs. - **The function of a combinational circuit can be given by a truth table of a Boolean equation**. The Boolean equation for any truth table can be obtained systematically using sum-of-products or product-of-sums form. In sum-of-products form, the function is written as the sum(OR) of one or more implicants. Implicants are the product(AND) of literals. Literals are the true or complementary forms of the input variables. - Boolean equations can be simplified using the rules of Boolean algebra. In particular, they can be simplified into minimal sum-of-products form by combing implicants that differ only in the true and complementary forms of one of the literals: $PA+P\\overline{A}=P(A+\\overline{A})=P\\,$. **Karnaugh maps are a visual tool for minimizing functions of up to four variables**. With practice, designers can usually simplify functions of a few variables by inspection. Computer-aided design tools(CAD) are used for more complicated functions; such methods and tools are discussed in Chapter 4. - (!!!)Logic gates are connected to create combinational circuits that perform the desired function. **Any function in sum-of-products form can be built using two-level logic: NOT gates form the complement of the inputs, AND gates form the products, and OR gates form the sum**. Depending on the function and the building blocks available, multilevel logic implementations with various types of gates may be more efficient. For example, CMOS circuits favor NAND and NOR gates because these gates can be built directly from CMOS transistors without requiring extra NOT gates. When using NAND and NOR gates, bubble pushing is helpful to keep track of the inversions. - (!!!)Logic gates are combined to produce larger circuits such as multiplexers, decoders, and priority circuits. A multiplexer chooses one of the data inputs based on the select input. A decoder sets one of the outputs HIGH according to the inputs. A priority circuit produces an output indicating the highest priority input. These circuits are all examples of combinational building blocks. Chapter 5 will introduce more building blocks, including other arithmetic circuits. These building blocks will be used extensively to build a microprocessor in Chapter 7. - The timing specification of a combinational circuit consists of the propagation and contamination delays through the circuit. These indicate the longest and shortest times between an input change and the consequent output change. Calculating the propagation delay of a circuit involves identifying the critical path through the circuit, then adding up the propagation delays of each element along that path. There are many different ways to implement complicated combinational circuits; these ways offer trade-offs between speed and cost. - The next chapter will move to sequential circuits, whose outputs depend on current as well as previous values of the inputs. In other words, sequential circuits have memory of the past."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#3-sequential-logic-design","title":"3 Sequential Logic Design","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#30-exercises","title":"3.0 Exercises","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#31-introduction","title":"3.1 Introduction","text":"\ud83d\udcd6 **Important takeaways**  - In the last chapter, we showed how to analyze and design combinational logic. **The output of combinational logic depends only on current input values**. Given a specification in the form of a truth table or Boolean equation, we can create an optimized circuit to meet the specification. - In this chapter, we will analyze and design sequential logic. **The output of sequential logic depend on both current and prior input values**. Hence, sequential logic has memory. - Sequential logic might explicitly remember certain previous inputs, or it might **distill the prior inputs into a smaller amount of information called the state of the system**. **The state of a digital sequential circuit is a set of bits called state variables** that contain all the information about the past necessary to explain the future behavior of the circuit. - The chapter begins by studying **latches and flip-flops,** which are **simple sequential circuits that store one bit of state**. - In general, sequential circuits are complicated to analyze. To simplify design, we discipline ourselves to build only synchronous circuits consisting of combinational logic and banks of flip-flops containing the state of the circuit. - The chapter describes **finite state machines**, which are **an easy way to design sequential circuits**. - Finally, we analyze the speed of sequential circuits and discuss **parallelism** as a way to **increase speed**."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#32-latches-and-flip-flops","title":"3.2 Latches and Flip-flops","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#320-background","title":"3.2.0 Background","text":"\ud83d\udcd6 **Background**  &gt; Just as Y is commonly used for the output of combinational logic, Q is commonly used for the output of sequential logic. &gt;  - The fundamental building block of memory is a **bistable element**, **an element with two stable states**. - Figure 3.1(a) shows a simple bistable element consisting of a pair of inverters connected in a loop. Figure 3.1(b) shows the same circuit redrawn to emphasize the symmetry. The inverters are cross-coupled, meaning that the input of I1 is the output of I2 and vice versa. The circuit has no inputs, but it does have two outputs, $Q\\,$and $\\overline{Q}\\,$. - Analyzing this circuit is different from analyzing a combinational circuit because it is cyclic: $Q\\,$depends on $\\overline{Q}\\,$, and $\\overline{Q}\\,$depends on $Q\\,$. - Consider the two cases, $Q\\,$is 0 and $Q\\,$is 1. Working through the consequences of each case, we have:     - Case 1: $Q=0\\,$(stable)          As shown in Figure 3.2(a), I2 receives a FALSE input, $Q\\,$, so it produces a TRUE output on $\\overline{Q}\\,$. I1 receives a TRUE input, $\\overline{Q}\\,$, so it produces a FALSE output on $Q\\,$. **This is consistent with the original assumption that $Q=0\\,$, so the case is said to be stable**.      - Case 2: $Q=1\\,$(stable)          As shown in Figure 3.2(b), I2 receives a TRUE input and produces a FALSE output on $\\overline{Q}\\,$. I1 receives a FALSE input and produces a TRUE output on $Q\\,$. This is again stable.   ![Screenshot 2023-01-31 at 10.34.26.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_10.34.26.png)  ![Screenshot 2023-01-31 at 18.59.17.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_18.59.17.png)  - **Because the cross-coupled inverters have two stable states, $Q=0\\,$and $Q=1$, the circuit is said to be bistable**. - A subtle point is that the circuit has a third possible state with both outputs approximately halfway between 0 and 1. This is called a metastable state and will be discussed in Section 3.5.4. - An element with $N\\,$stable states conveys $\\log_2{N}\\,$bits of information, so a bistable element stores one bit. - The state of the cross-coupled inverters is contained in one binary state variable, $Q$. The value of $Q\\,$tells us everything about the past that is necessary to explain the future behavior of the circuit. Specifically, if $Q=0$, it will remain 0 forever, and if $Q=1$, it will remain 1 forever. The circuit does have another node, $\\overline{Q}$, but $\\overline{Q}\\,$does not contain **any additional information** because if $Q\\,$is known, $\\overline{Q}\\,$is also known. On the other hand, $\\overline{Q}\\,$is also an acceptable choice for the state variable. - **When power is first applied to a sequential circuit, the initial state is unknown and usually unpredictable**. It may differ each time the circuit is turned on. - Although the **cross-coupled inverters** can store a bit of information, they are not practical because the user has **no inputs to control the state**. - However, other bistable elements, such as latches and flip-flops, provide inputs to control the value of the state variable. The remainder of this section considers these circuits."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#321-sr-latch","title":"3.2.1 SR Latch(?!!!)","text":"\ud83d\udcd6 **Important takeaways**  - One of the simplest sequential circuits is the SR latch, which is composed of two cross-coupled NOR gates, as shown in Figure 3.3. The latch has two inputs, S and R, and two outputs, $Q\\,$and $\\overline{Q}$. - The SR latch is similar to the cross-coupled inverters, but its state can be controlled through the S and R inputs, which set(S) and reset(R) the output $Q$.  ![Screenshot 2023-01-31 at 20.11.43.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_20.11.43.png)  ![Screenshot 2023-01-31 at 20.11.56.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_20.11.56.png)  ![Screenshot 2023-01-31 at 20.07.43.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_20.07.43.png)  ![Screenshot 2023-01-31 at 20.12.07.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_20.12.07.png)  ![Screenshot 2023-01-31 at 20.12.17.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_20.12.17.png)  - Putting this all together, suppose $Q\\,$has some known prior value, which we will call $Q_{prev}\\,$, before we enter Case IV. $Q_{prev}\\,$is either 0 or 1, and represents the state of the system. - **When R and S are 0, $Q\\,$will remember this old value, $Q_{prev}$**, and $\\overline{Q}\\,$will be its complement(the complement of $\\overline{Q_{prev}}$ ). The circuit has memory. - The truth table in Figure 3.5 summarizes these four cases. **The inputs S and R stand for Set and Reset**. To set a bit means to make it TRUE. To reset a bit means to make it FALSE. The outputs, $Q\\,$and $\\overline{Q}\\,$, are normally complementary. - When S is asserted(and R is not asserted), Q is set to 1 and $\\overline{Q}\\,$does the opposite($\\overline{Q}\\,$is set to 0). - When R is asserted(and S is not asserted), Q is set to 0 and $\\overline{Q}\\,$does the opposite($\\overline{Q}\\,$is set to 1). - When neither input is asserted, Q remembers its old value, $Q_{prev}$. - **Asserting both S and R simultaneously doesn\u2019t make much sense** because it means the latch should **be set and reset at the same time**, which is impossible. The poor confused circuit responds by making both outputs 0. - Any circuit element with the relationship specified by the truth table in Figure 3.5 and the symbol in Figure 3.6 is called an SR latch. - Like the cross-coupled inverters, the SR latch is a bistable element with one bit of state stored in $Q\\,$. However, the state can be controlled through the S and R inputs.     - When R is asserted, the state is reset to 0(the state of $Q$).     - When S is asserted, the state is set to 1(the state of $Q$).     - When neither is asserted, the state retains its old value. - (?)Notice that the entire history of inputs can be accounted for by the single state variable $Q\\,$. No matter what pattern of setting and resetting occured in the past, all that is needed to predict the future behavior of the SR latch is **whether it was most recently set or reset**."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#322-d-latch","title":"3.2.2 D Latch","text":"\ud83d\udcd6 **Important takeaways**  - The SR latch is awkward because **it behaves strangely when both S and R are simultaneously asserted**. Moreover, the S and R inputs conflate the issues of what and when. Asserting one of the inputs determines not only what the state should be but also when it should change. - Designing circuits becomes easier when these questions of what and when are separated. - The D latch in Figure 3.7(a) solves these problems. It has two inputs.     - The data input, $D$, controls what the next state should be.     - The clock input, $CLK$, controls when the state should change.  ![Screenshot 2023-01-31 at 21.12.56.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_21.12.56.png)  ![Screenshot 2023-01-31 at 20.12.07.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_20.12.07%201.png)  - Again, we analyze the latch by writing the truth table, given in Figure 3.7(b). For convenience, we first consider the internal nodes $\\overline{D}$, $S$, and $R$.     - If $CLK=0$, both S and R are FALSE, regardless of the value of $D$.(first row in Figure 3.5)     - **If $CLK=1$, one AND gate will produce TRUE and the other FALSE**, depending on the value of $D$.     - Given S and R, $Q\\,$and $\\overline{Q}\\,$are determined using Figure 3.5. - Observe that when $CLK=0$, $Q\\,$remembers its old value, $Q_{prev}$. When $CLK=1$, $Q=D$.$(D=1, S(set)=1, Q=1; D=0, R(reset)=1, Q=0)$. - The D latch avoids the strange case of simultaneously asserted R and S inputs. - Putting it all together, we see that **the clock controls when data flows through the latch**.     - **When $CLK=1$, the latch is transparent**. The data at $D\\,$flows through to $Q\\,$as if the latch were just a buffer.     - **When $CLK=0$, the latch is opaque**. It **blocks** the **new data** from flowing through to $Q$, and $**Q\\,$retains the old value**. - Hence, the D latch is sometimes called a transparent latch or a level-sensitive latch. The D latch symbol is given in Figure 3.7(c). - The D latch updates its state continuously while $CLK=1$. We shall see later in this chapter that it is useful to update the state only at a specific instant in time. The D flip-flop described in the next section does just that."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#323-d-flip-flop","title":"3.2.3 D Flip-Flop(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - A D flip-flop can be built from two back-to-back D latches controlled by complementary clocks, as shown in Figure 3.8(a). - The first latch, L1, is called the master. The second latch, L2, is called the slave. The node between them is named N1. A symbol for the D flip-flop is given in Figure 3.8(b). When the $\\overline{Q}\\,$output is not needed, the symbol is often condensed as in Figure 3.8(c). - When $**CLK=0**$, the **master branch** is **transparent** and the **slave branch** is **opaque**. Therefore, whatever value was at D propagates through to N1.      When $CLK=1$, the master goes opaque and the slave becomes transparent. The value at N1 propagates to Q(on the right hand side), but N1 is cut off from D.      (When $**CLK=1**$, the **master branch** is **opaque** and the **slave branch** is **transparent**.)      | CLK | master | slave | path |     | --- | --- | --- | --- |     | 0 | transparent | opaque | $D\\rightarrow N1\\nrightarrow Q$ |     | 1 | opaque | transparent | $D\\nrightarrow N1\\rightarrow Q$ | - Hence, whatever value was at D **immediately before** the clock rises from 0 to 1 gets copied to Q **immediately after** the clock rises. At all other times, $Q\\,$retains its old value, because there is always an opaque latch blocking the path between D and $Q$. - In other words, a D flip-flop copies D to $Q\\,$on the rising edge of the clock, and remembers its state at all other times. - The rising edge of the clock is often just called the clock edge for brevity. - The D input specifies what the new state will be. The clock edge indicates when the state should be updated.(CLK 0\u21921) - A D flip-flop is also known as a master-slave flip-flop, an edge-triggered flip-flop, or a positive edge-triggered flip-flop. The triangle in the symbols denotes an edge-triggered clock input. The $\\overline{Q}\\,$output is often omitted when it is not needed.  ![Screenshot 2023-01-31 at 21.51.08.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_21.51.08.png)  ![Screenshot 2023-01-31 at 22.27.41.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_22.27.41.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#324-register","title":"3.2.4 Register","text":"\ud83d\udcd6 **Important takeaways**  - An $N$-bit register is a bank of $N$ flip-flops that share a common $CLK$ input, so that **all bits of the register are updated at the same time**. - Registers are the key building block of most sequential circuits. - Figure 3.9 shows the schematic and symbol for a four-bit register with inputs $D_{3:0}\\,$and outputs $Q_{3:0}$. $D_{3:0}\\,$and $Q_{3:0}\\,$are both 4-bit busses.  ![Screenshot 2023-01-31 at 22.36.04.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_22.36.04.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#325-enabled-flip-flop","title":"3.2.5 Enabled Flip-Flop","text":"\ud83d\udcd6 **Important takeaways**  - An enabled flip-flop adds another input called $EN$ or $ENABLE$ to determine whether data is loaded on the clock edge. - When $EN$ is TRUE, the enabled flip-flop behaves like an ordinary D flip-flop. When $EN$ is FALSE, the enabled flip-flop ignores the clock and retains its state. - Enabled flip-flops are useful when we wish to load a new value into a flip-flop only some of the time, rather than on every clock edge.  - Figure 3.10 shows two ways to construct an enabled flip-flop from a D flip-flop and an extra gate. In Figure 3.10(a), **an input multiplexer** chooses whether to **pass the value at D, if $EN$ is TRUE**, or to **recycle the old state from Q, if $EN\\,$is FALSE**.      \u6ce8\uff1a\u5728Figure 3.10(a)\u4e2d, D\u4e0e1\u8fde\u63a5, Q\u51fa\u53e3($Q_{prev}$)\u4e0e0\u8fde\u63a5\u3002  - In Figure 3.10(b), the clock is gated. If $EN\\,$is TRUE, the $CLK\\,$input to the flip-flop toggles normally. If $EN\\,$is FALSE, the $CLK$ input is also FALSE and the flip-flop retains its old value. - Notice that $EN\\,$must not change while $CLK=1$, lest the flip-flop see a clock glitch(switch at an incorrect time). - Generally, performing logic on the clock is a bad idea. Clock gating delays the clock and can cause timing errors, as we will see in Section 3.5.3, so do it only if your are sure you know what you are doing. - The symbol for an enabled flip-flop is given in Figure 3.10(c).  ![Screenshot 2023-01-31 at 23.53.31.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-01-31_at_23.53.31.png)  - \u6211\u4eec\u73b0\u5728\u7684\u4efb\u52a1\u5c31\u662f\u601d\u8003\u5982\u4f55\u6784\u5efa\u8fd9\u6837\u7684\u4e00\u4e2aenabled flip-flop. \u6839\u636eenabled flip-flop\u7684\u529f\u80fd\u53d9\u8ff0\uff0c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\uff0c\u5f53EN=1\u65f6\uff0cD\u8981\u628a\u81ea\u8eab\u7684\u5185\u5bb9\u4f20\u9012\u7ed9Q\uff0c\u5f53EN=0\u65f6\uff0cQ\u8981\u4fdd\u6301\u81ea\u5df1\u539f\u6709\u7684\u72b6\u6001\uff0c\u56e0\u6b64D\u76f8\u5f53\u4e8e\u8981\u628a$Q_{prev}\\,$\u7684\u5185\u5bb9\u4f20\u9012\u7ed9Q\u3002 - \u6ce8\u610f\u5728\u4e0a\u9762\u7684\u53d9\u8ff0\u4e2d\uff0c\u5e76\u4e0d\u662f\u8bf4\u5f53EN=1\u65f6\uff0cD\u5c31\u76f4\u63a5\u628a\u81ea\u8eab\u7684\u5185\u5bb9\u4f20\u9012\u7ed9Q\u4e86\uff0c\u800c\u662f\u8bf4\u5f53EN=1\u65f6\uff0c\u6b64\u65f6enabled flip-flop\u4e0e\u4e00\u4e2a\u5e38\u89c4\u7684D flip-flop\u6ca1\u6709\u4efb\u4f55\u533a\u522b\uff0c\u4f9d\u7136\u4f1a\u5728CLK\u75310\u8f6c1\u7684\u65f6\u5019\u5b8c\u6210\u4fe1\u53f7\u7531D\u5230Q\u7684\u4f20\u9012(\u5f53CLK=0\u65f6\uff0cmaster\u662ftransparent\uff0cslave\u662fopaque\uff0c\u6b64\u65f6\u4fe1\u53f7\u505c\u5728\u4e2d\u95f4\u5230\u4e0d\u4e86Q\uff1b\u5f53CLK\u75310\u53d81\u7684\u65f6\u5019\uff0cmaster\u662fopaque\uff0cslave\u662ftransparent\uff0c\u6b64\u65f6\u4fe1\u53f7\u7531\u4e2d\u95f4\u5230\u8fbeQ\uff0c\u540c\u65f6D\u7684\u4fe1\u53f7\u65e0\u6cd5\u5230\u8fbe\u4e2d\u95f4)\u3002 - \u800c\u5728EN=0\u7684\u65f6\u5019\uff0c\u7531\u4e8e\u6211\u4eec\u7684\u76ee\u6807\u662f\u8981\u8ba9Q\u4fdd\u6301$Q_{prev}\\,$\u7684\u72b6\u6001\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u8ba9D\u7684\u8f93\u5165\u7aef\u53e3\u59cb\u7ec8\u4e0e$Q_{prev}\\,$\u76f8\u8fde\uff0c\u8fd9\u6837\u65e0\u8bbaCLK\u662f\u4ec0\u4e48\u6837\u7684\u72b6\u6001\uff0cQ\u7684\u72b6\u6001\u90fd\u4e0d\u4f1a\u53d1\u751f\u6539\u53d8\uff0c\u4e00\u76f4\u4fdd\u6301$Q_{prev}\\,$\u7684\u72b6\u6001\u3002 - \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u753b\u51fa\u53f3\u4fa7\u7684\u4e00\u4e2atruth table\u5e76\u5199\u51fa\u4e0e\u8fd9\u4e2atruth table\u76f8\u5bf9\u5e94\u7684$D_{in}\\,$\u7684\u4e00\u4e2aequation\uff0c\u6839\u636e\u8fd9\u4e2aequation\u6211\u4eec\u80fd\u591f\u753b\u51fa\u5982\u56fe\u6240\u793a\u7684\u7535\u8def\u56fe\u3002\u5982\u679c\u6211\u4eec\u5ffd\u7565\u5177\u4f53\u6784\u5efa\u7684\u7ec6\u8282\uff0c\u5c06\u5176\u5c01\u88c5\u5728\u4e00\u4e2a\u7ea2\u8272\u6846\u4e2d\uff0c\u6211\u4eec\u4fbf\u5f97\u5230\u4e86\u5e7b\u706f\u7247\u4e2d\u5448\u73b0\u7684enabled flip-flop\u7684\u6807\u5fd7\uff0c\u7ea2\u6846\u5916\u4fa7\u5373\u662fenabled flip-flop\u7684\u5404\u79cd\u8f93\u5165\u8f93\u51fa\u7aef\u53e3\u3002  ![IMG_4DEC4A63CFB8-1.jpeg](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/IMG_4DEC4A63CFB8-1.jpeg)  ![IMG_738EA1C346F8-1.jpeg](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/IMG_738EA1C346F8-1.jpeg)  ![Screen Shot 2023-02-01 at 08.38.32.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screen_Shot_2023-02-01_at_08.38.32.png)  ![IMG_98BD07584F1D-1.jpeg](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/IMG_98BD07584F1D-1.jpeg)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#326-resettable-flip-flop","title":"3.2.6 Resettable Flip-Flop","text":"\ud83d\udcd6 **Important takeaways**  - A resettable flip-flop adds another input called RESET. When RESET is FALSE, the resettable flip-flop haves like an ordinary D flip-flop. When RESET is TRUE, the resettable flip-flop ignores D and resets the output to 0(next clock edge). - Resettable flip-flops are useful when we want to force a known state(i.e., 0) into all the flip-flops in a system when we first turn it on. - Such flip-flops may be synchronously or asynchronously resettable. Synchronously resettable flip-flops reset themselves only on the rising edge of CLK. Asynchronously resettable flip-flops reset themselves as soon as RESET becomes TRUE, independent of CLK. - Figure 3.11(a) shows how to construct a synchronously resettable flip-flop from an ordinary D flip-flop and an AND gate.     - When RESET is TRUE($\\overline{RESET}$ is FALSE), the AND gate forces a 0 into the input of the flip-flop.     - When RESET is FALSE($\\overline{RESET}$ is TRUE), the AND gate passes D to the flip-flop.      | RESET | $D_{in}$ |     | --- | --- |     | 1 | 0 |     | 0 | D |      $$     D_{in}=\\overline{RESET}\\cdot D     $$   ![Screen Shot 2023-02-01 at 09.21.31.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screen_Shot_2023-02-01_at_09.21.31.png)  ![Screen Shot 2023-02-01 at 09.26.59.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screen_Shot_2023-02-01_at_09.26.59.png)  - In this example, $\\overline{RESET}$ is an active low signal, meaning that the reset signal performs its function when it is 0, not 1. - By adding an inverter, the circuit could have accepted an active high reset signal instead. Figure 3.11(b) and Figure 3.11(c) show symbols for the resettable flip-flop with active high reset. - Asynchronously resettable flip-flops require modifying the internal structure of the flip-flop and are left to you to design in Exercise 3.13; however, they are frequently available to the designer as a standard component. - As you might imagine, settable flip-flops are also occasionally used. They load a 1 into the flip-flop when SET is asserted, and they too come in synchronous and asynchronous flavors. Resettable and settable flip-flops may also have an enable input and may be grouped into $N$-bit registers.  | SET | $D_{in}$ | | --- | --- | | 1 | 1 | | 0 | D |  $$ D_{in}=SET+\\overline{SET}\\cdot D $$  ![IMG_5018522C4FB7-1.jpeg](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/IMG_5018522C4FB7-1.jpeg)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#327","title":"3.2.7","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#328-putting-it-all-together","title":"3.2.8 Putting It All Together","text":"\ud83d\udcd6 **Important takeaways**  - Latches and flip-flops are the fundamental building blocks of sequential circuits. - Remember that a D latch is level-sensitive, whereas a D flip-flop is edge-triggered. - The D latch is transparent when CLK=1, allowing the input D to flow through to the output Q. - The D flip-flop copies D to Q on the rising edge of CLK. At all other times, latches and flip-flops retain their old state. - A register is a bank of several D flip-flops that share a common CLK signal.  - \u9996\u5148\uff0c\u8ba9\u6211\u4eec\u6765\u8003\u8651 D latch\u3002D latch\u7684\u5de5\u4f5c\u7279\u70b9\u662f\u5f53CLK=1\u65f6\uff0c\u6839\u636eD\u7684\u60c5\u51b5\u6765\u786e\u5b9a\u8f93\u51faQ\u7684\u72b6\u6001\uff0cCLK=1\u65f6\uff0c\u82e5D=1\uff0c\u5219Q=1\uff1b\u82e5D=0\uff0c\u5219Q=0\u3002\u800c\u5f53CLK=0\u65f6\uff0cQ\u4fdd\u6301$Q_{prev}\\,$\u3002     1. \u521d\u59cb\u7684\u65f6\u5019Q\u7684\u72b6\u6001\u672a\u77e5\uff0c\u65e2\u6709\u53ef\u80fd\u662f0\uff0c\u4e5f\u6709\u53ef\u80fd\u662f1\u3002     2. \u5728\u56fe\u4e2d\uff0cCLK\u7b2c\u4e00\u4e2a\u75310\u8f6c1\u7684\u8fc7\u7a0b\u4e2d\uff0c\u7b2c\u4e8c\u884c\u4e2dD\u5904\u5728LOW\u7684\u72b6\u6001\uff0c\u6240\u4ee5Q\u4e5f\u5904\u5728LOW\u7684\u72b6\u6001\u3002     3. \u5f53D\u75310\u8f6c1\u540e\uff0c\u7531\u4e8e\u6b64\u65f6CLK=1\uff0c\u6240\u4ee5Q\u4f1a\u53d8\u4e3aHIGH\u7684\u72b6\u6001\u3002     4. CLK=1\u7684\u65f6\u5019\uff0c\u56e0\u4e3aD\u7684\u72b6\u6001\u4e0d\u53d8\uff0c\u6240\u4ee5Q\u7684\u72b6\u6001\u4e0d\u53d8\u3002     5. \u5728CLK\u7b2c\u4e00\u6b21\u75311\u53d8\u4e3a0\u540e\uff0cQ\u4fdd\u6301HIGH\u7684\u72b6\u6001\u3002     6. CLK\u7b2c\u4e8c\u4e2a\u75310\u8f6c1\u7684\u8fc7\u7a0b\u4e2d\uff0cD\u4ecd\u5904\u5728HIGH\u7684\u72b6\u6001\uff0c\u6545Q\u4f9d\u7136\u4fdd\u6301HIGH\u3002     7. CLK=1\u7684\u65f6\u5019\uff0cQ\u7684\u53d8\u5316\u4e0eD\u7684\u53d8\u5316\u5b8c\u5168\u76f8\u540c\uff0c\u5148\u964d\u540e\u5347\u3002     8. CLK=0\u7684\u65f6\u5019\uff0c\u7ee7\u7eed\u4fdd\u6301HIGH\u5230\u7ed3\u675f\u3002  ![Screenshot 2023-02-01 at 10.59.05.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_10.59.05.png)  ![Screenshot 2023-02-01 at 10.58.40.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_10.58.40.png)  - \u5176\u6b21\uff0c\u8ba9\u6211\u4eec\u6765\u8003\u8651 D flip-flop\u3002      On each rising edge of CLK, D is copied to Q. At all other times, Q retains its state."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#33-synchronous-logic-design","title":"3.3  Synchronous Logic Design","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#330-background","title":"3.3.0 Background","text":"\ud83d\udcd6 **Background**  - In general, **sequential circuits** include all circuits that are not combinational \u2014 that is, **whose output cannot be determined simply by looking at the current inputs**. Some sequential circuits are just plain kooky. - This section begins by examining some of those curious circuits. It then introduces the notion of **synchronous sequential circuits** and **the dynamic discipline**. - By **disciplining ourselves to synchronous sequential circuits**, we can develop easy, systematic ways to analyze and design sequential systems."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#331-some-problematic-circuits","title":"3.3.1 Some Problematic Circuits","text":"\ud83d\udcd6 **Important takeaways**  - **Astable circuits**      ![Screenshot 2023-02-01 at 13.52.52.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_13.52.52.png)      ![Screenshot 2023-02-01 at 13.53.31.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_13.53.31.png)      ![Screenshot 2023-02-01 at 13.53.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_13.53.11.png)   - **Race Conditions(!!!)**      Ben Bitdiddle designed a new D latch that he claims is better than the one in Figure 3.7 because it uses fewer gates. He has written the truth table to find the output, $Q$, given the two inputs, D and CLK, and the old state of the latch, $Q_{prev}$. Based on this truth table, he has derived Boolean equations. He obtained $Q_{prev}\\,$by feeding back the output, $Q$. His design is shown in Figure 3.18. Does his latch work correctly, independent of the delays of each gate?      ![Screenshot 2023-02-01 at 14.06.26.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_14.06.26.png)      \u81ea\u5df1\u5c1d\u8bd5\u590d\u8ff0\u95ee\u9898\u539f\u56e0\uff1a\u8fd9\u91cc\u4e3b\u8981\u6d89\u53ca\u5230\u4e86\u4e0d\u540c\u7684\u95e8\u5ef6\u8fdf\u65f6\u95f4\u957f\u77ed\u7684\u95ee\u9898\u3002      1. \u5047\u8bbeD\u548cCLK\u521d\u59cb\u72b6\u6001\u90fd\u4e3a1(HIGH),\u6b64\u65f6Q\u7684\u72b6\u6001\u4e5f\u662f1(HIGH)\u3002     2. \u73b0\u5728\u6211\u4eec\u5047\u8bbeCLK\u75311\u53d8\u4e3a0\uff0c\u5e76\u4e14OR gate\u548cAND gate\u7684delay\u6bd4inverter\u7684delay\u8981\u77ed\uff0c\u5f53CLK\u75311\u53d8\u4e3a0\u540e\uff0cN1\u5904\u4f1a\u8f83\u5feb\u5730\u53d8\u4e3a0\uff0c\u540c\u65f6\u7531\u4e8e\u521d\u59cb\u65f6CLK\u662f1\uff0c\u5bfc\u81f4N2\u5904\u662f0\u3002     3. \u7531\u4e8einverter\u7684delay\u6bd4\u8f83\u957f\uff0c\u6240\u4ee5N2\u5904\u53d8\u4e3a1\u7684\u65f6\u95f4\u6bd4\u8f83\u957f\uff0c\u56e0\u6b64\u8fd9\u4e2a\u65f6\u5019\u53ef\u4ee5\u8ba4\u4e3aN2\u5904\u8fd8\u6ca1\u6709\u53d8\u4e3a1\uff0c\u8fd8\u662f0\u7684\u72b6\u6001\uff0cN1,N2\u90fd\u662f0\uff0cQ\u4e5f\u662f0\uff0c\u5bfc\u81f4\u8fd4\u56de\u7684$Q_{prev}$\u4e5f\u53d8\u6210\u4e860\u3002     4. \u90a3\u4e48\u8fd9\u4e2a\u65f6\u5019\u5373\u4f7fCLK\u53d8\u6210\u4e860\uff0c\u672c\u6765\u6b64\u65f6\u6309\u7167\u8bbe\u60f3Q\u5e94\u8be5\u4fdd\u63011\u7684\u72b6\u6001\uff0c\u4f46\u662f\u7531\u4e8e$Q_{prev}\\,$\u5904\u63d0\u524d\u53d8\u4e3a\u4e860\uff0c\u5bfc\u81f4N2\u5904\u4ecd\u672a0\uff0c\u5bfc\u81f4Q\u4f1a\u5f85\u57280\u7684\u72b6\u6001\u4e0d\u518d\u52a8\u4e86\u3002  **Solution**:   - Figure 3.19 shows that **the circuit has a race condition** that causes it to **fail when certain gates are slower than others**. - Suppose CLK=D=1. The latch is transparent and passes D through to make Q=1. - Now, CLK falls. The latch **should** remember its old value, keeping Q=1. - However, suppose the delay through the inverter from CLK to $\\overline{CLK}$ is rather long compared to the delays of the AND and OR gates. Then **nodes N1 and Q($\\overline{CLK}$ is still 0, thus N2 is 0) may both fall before $\\overline{CLK}$ rises**. In such a case, N2 will never rise, and **Q becomes stuck at 0**.  &gt; This is an example of asynchronous circuit design in which **outputs are directly feed back to inputs(something that we should avoid)**. Asynchronous circuits are infamous for having race conditions where **the behavior of the circuit depends on which of two paths through logic gates is fastest**. One circuit may work, while a seemingly identical one built from gates **with slightly different delays** may not work. Or the circuit may work only at certain temperatures or voltages at which the delays are just right. These malfunctions are extremely difficult to track down. &gt;"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#332-synchronous-sequential-circuits","title":"3.3.2 Synchronous Sequential Circuits(?!!!)","text":"\ud83d\udcd6 **Important takeaways**  - The previous two examples contain **loops** called **cyclic paths**, in which **outputs are fed directly back to inputs**. They are sequential rather than combinational circuits.     - Combinational logic has no cyclic paths and no races. If inputs are applied to combinational logic, the outputs will always settle to the correct value **within a propagation delay**.     - However, **sequential circuits with cyclic paths** can have **undesirable races or unstable behavior**. Analyzing such circuits for problems is time-consuming. - To avoid these problems, designer **break the cyclic paths** by **inserting registers somewhere in the path**.     - This transforms the circuit into **a collection of combinational logic and registers**.(Recall that an N-bit register is a bank of N flip-flops that share a common $CLK$ input, so that all bits of the register are updated at the same time)     - The **registers** contain the **state of the system**, which **changes only at the clock edge**, so we say the state is synchronized to the clock.     - (?!!!)If the clock is sufficiently slow, so that the inputs to all registers settle before the next clock edge, all races are eliminated.     - Adopting this discipline of **always using registers in the feedback path** leads us to the formal definition of a synchronous sequential circuit. - The rules of synchronous sequential circuit composition teach us that a circuit is a synchronous sequential circuit if it consists of interconnected circuit elements such that:     1. **Every circuit element** is either a **register** or a **combinational circuit**.     2. **At least one** circuit element is a **register**.     3. **All registers** receive the **same clock signal**.     4. **Every cyclic path** contains **at least one register**.     5."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#34-finite-state-machines","title":"3.4 Finite State Machines","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#340-background","title":"3.4.0 Background(?!!!)","text":"\ud83d\udcd6 **Background**  - Synchronous sequential circuits can be drawn in the forms shown in Figure 3.22. These forms are called finite state machines(FSMs). - They get their name because **a circuit with $k$ registers can be in one of a finite number($2^k$) of unique states**. - An FSM has $M$ inputs, $N$ outputs and $k$ bits of state. It also receives a clock and, optionally, a reset signal. - An FSM consists of two blocks of combinational logic, next state logic and output logic, and a register that stores the state. - On **each clock edge**, the FSM advances to **the next state**, which **was computed** **based on the current state and inputs**. - **output dependencies**     - (?!!!)There are two general classes of finite state machines, characterized by their functional specifications(?).     - In Moore machines, the outputs depend only on the current state of the machine.     - In Mealy machines, the outputs depend on both the current state and the current inputs.     - This method will be explained in the remainder of this section, starting with an example.  ![Screenshot 2023-02-01 at 15.28.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_15.28.36.png)  |  | Moore machines | Mealy machines | | --- | --- | --- | | current state | \u2705 | \u2705 | | current input | \u274c | \u2705 |"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#341-fsmfinite-state-machine-design-example","title":"3.4.1 FSM(Finite State Machine) Design Example","text":"\ud83d\udcd6 **Important takeaways**  - To illustrate the design of FSMs, consider the problem of **inventing a controller for a traffic light at a busy intersection on campus**. The Dean of Students asks Ben Bitdiddle to install a traffic light before there are any fatalities.  ![Screenshot 2023-02-02 at 09.50.19.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_09.50.19.png)  - Ben decides to solve the problem with an FSM. He installs two traffic sensors, $T_A$ and $T_B$, on Academic Ave. and Bravado Blvd., respectively. **Each sensor indicates TRUE if students are at present and FALSE if the street is empty**. - He also installs two traffic lights, $L_A$ and $L_B$, to control traffic. Each light receives digital inputs specifying whether it should be green, yellow, or red. - Hence, his FSM has two inputs, $T_A$ and $T_B$, and two outputs, $L_A$ and $L_B$. The intersection with lights and sensors is shown in Figure 3.23. - Ben provides a **clock** with a 5-second period. On each clock tick(rising edge), the lights may change based on the traffic sensors. He also provides **a reset button** so that Physical Plant technicians can put the controller in a **known initial state** **when they turn it on**. Figure 3.24 shows a black box view of the state machine.  ![Screenshot 2023-02-02 at 09.50.33.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_09.50.33.png)  - Ben\u2019s next step is to sketch the **state transition diagram**, shown in Figure 3.25, to **indicate all the possible states of the system and the transitions between them**.  ![Screenshot 2023-02-02 at 10.01.57.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_10.01.57.png)  1. When the **system is reset**, the lights are **green on Academic Ave.** and **red on Bravado Blvd**.(S0) 2. Every 5 seconds, the controller examines the traffic pattern and decides what to do next. 3. As long as traffic is present on Academic Ave., the lights do not change. When there is no longer traffic on Academic Ave., the light on Academic Ave becomes yellow for 5 seconds(S1) before it turns red and Bravado Blvd.\u2019s light turns green.(S2) 4. Similarly, the Bravado Blvd. light remains green as long as traffic is present on the boulevard, then turns yellow(S3) and eventually turns red.(S0) - In a **state transition diagram**, circles represent states and arcs represent transitions between states. - The transitions take place on the **rising edge of the clock**; we do not bother to show the clock on the diagram, because it is always present in a synchronous sequential circuit. - Moreover, the **clock simply controls when the transitions should occur**, whereas **the diagram indicates which transitions occur**. - The arc labeled Reset pointing from outer space into state S0 indicates that the system should enter that state upon reset, regardless of what previous state if was in. - If **a state has multiple arcs leaving it**, the arcs are labeled to show what inputs triggers each transition.     - For example, when in state $S0$, the system will remain in that state if $T_A$ is TRUE and move to $S1$ if $T_A$ is FALSE. - If a state has **a single arc leaving it**, **that transition always occurs regardless of the inputs**.     - For example, when in state $S1$, the system will always move to $S2$. - The value that the outputs have while in a particular state are indicated in the state.     - For example, while in state $S2$, $L_A$ is red and $L_B$ is green. - Ben **rewrites the state transition diagram as a state transition table**(Table 3.1), which indicates, for each state and input, what the next state, $S^\\prime$, should be. Note that **the table uses don\u2019t care symbols(X) whenever the next state does not depend on a particular input**. - Also note that Reset is omitted from the table. Instead, we use resettable flip-flops that always go to $S0$ on reset, independent of the inputs. - The state transition diagram is abstract in that it uses states labeled$\\{S0, S1, S2, S3\\}$ and outputs labeled $\\{\\mathrm{red, yellow, green}\\}$. To build a real circuit, the states and outputs must be assigned **binary encodings**. Ben chooses the simple codings given in Table 3.2 and 3.3. Each state and each output is encoded with two bits: $S_{1:0}$, $L_{A1:0}$, and $L_{B1:0}$.  ![Screenshot 2023-02-02 at 11.04.49.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_11.04.49.png)  &gt; Notice that states are designated as $S0$, $S1$, etc. The subscripted versions, $S_0$, $S_1$, etc., refer to the state bits. &gt;  - Ben updates the state transition table to use these binary encodings, as shown in Table 3.4. The revised state transition table is a truth table specifying the next state logic. It defines next state, $S^\\prime$, as a function of the current state, $S$, and the inputs.      ![Screenshot 2023-02-02 at 11.12.05.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_11.12.05.png)  - From this table, it is straightforward to read off the Boolean equation for the next state in sum-of-products form.      $$     \\begin{align*}S_1^\\prime&amp;=\\overline{S_1}S_0+S_1\\overline{S_0}\\,\\overline{T_B}+S_1\\overline{S_0}T_B\\\\S_0^\\prime&amp;=\\overline{S_1}\\,\\overline{S_0}\\,\\overline{T_A}+S_1\\overline{S_0}\\,\\overline{T_B}\\end{align*}     $$      The equations can be simplified using Karnaugh maps, but often doing it by inspection is easier.      $$     \\begin{align*}S_1^\\prime&amp;=\\overline{S_1}S_0+S_1\\overline{S_0}\\,\\overline{T_B}+S_1\\overline{S_0}T_B\\\\&amp;=\\overline{S_1}S_0+S_1\\overline{S_0}(\\overline{T_B}+T_B)\\\\&amp;=\\overline{S_1}S_0+S_1\\overline{S_0}\\\\&amp;=S_1\\oplus S_0\\end{align*}     $$      | $T_AT_B/S_1S_0$ | 00 | 01 | 11 | 10 |     | --- | --- | --- | --- | --- |     | 00 | 0 | 1 | 0 | 1 |     | 01 | 0 | 1 | 0 | 1 |     | 11 | 0 | 1 | 0 | 1 |     | 10 | 0 | 1 | 0 | 1 |      $$     \\begin{align*}S_1^\\prime&amp;=S_1\\oplus S_0\\\\S_0^\\prime&amp;=\\overline{S_1}\\,\\overline{S_0}\\,\\overline{T_A}+S_1\\overline{S_0}\\,\\overline{T_B}\\end{align*}     $$   - Similarly, Ben writes an output table(Table 3.5) indicating, for each state, what the output should be in that state. Again, it is straightforward to read off and simplify the Boolean equations for the outputs.      $$     \\begin{align*}L_{A1}&amp;=S_1\\\\L_{A0}&amp;=\\overline{S_1}S_0\\\\L_{B1}&amp;=\\overline{S_1}\\\\L_{B0}&amp;=S_1S_0\\end{align*}     $$      ![Screenshot 2023-02-02 at 11.37.27.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_11.37.27.png)      | $S_1^\\prime$ | $S_0^\\prime$ | $L_{A1}$ | $L_{A0}$ | $L_{B1}$ | $L_{B0}$ |     | --- | --- | --- | --- | --- | --- |     | 0 | 0 | 0 | 0 | 1 | 0 |     | 0 | 1 | 0 | 1 | 1 | 0 |     | 1 | 0 | 1 | 0 | 0 | 0 |     | 1 | 1 | 1 | 0 | 0 | 1 | - Finally, Ben sketches his Moore FSM in the form of Figure 3.22(a).     - **First**, he draws the 2-bit state **register**(because there are four states), as shown in Figure 3.26(a). On each clock edge, the state register copies the next state, $S_{1:0}^\\prime$, to become the state $S_{1:0}$. The state register receives a synchronous or asynchronous reset to initialize the FSM at startup.     - **Then**, he draws the **next state logic**, based on Equation 3.2, which **computes the next state from the current state and inputs**, as shown in Figure 3.26(b).     - **Finally**, he draws the **output logic**, based on Equation 3.3, which computes the outputs from the current state, as shown in Figure 3.26(c).          $$         \\begin{align*}S_1^\\prime&amp;=S_1\\oplus S_0\\\\S_0^\\prime&amp;=\\overline{S_1}\\,\\overline{S_0}\\,\\overline{T_A}+S_1\\overline{S_0}\\,\\overline{T_B}\\end{align*}         $$       ![Screenshot 2023-02-01 at 15.28.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_15.28.36%201.png)      ![Screenshot 2023-02-02 at 14.33.56.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_14.33.56.png)  - Figure 3.27 shows a timing diagram illustrating the traffic light controller going through a sequence of states. The diagram shows CLK, Reset, the inputs $T_A$ and $T_B$, next state $S^\\prime$, state $S$, and outputs $L_A$ and $L_B$. - Arrows indicate causality; for example, **changing the state** causes the **outputs to change**, and **changing the inputs** causes the **next state to change**($T_A$ and $\\overline{T_A}$). - The clock has a 5-second period, so the traffic lights change at most once every 5 seconds. When the finite state machine is first turned on, its state is unknown, as indicated by the question marks. Therefore, the system should be reset to put it into a known state. In this timing diagram, $S$ immediately resets to $S0$, indicating that asynchronously resettable flip-flops are being used. In state $S0$, light $L_A$ is green and light $L_B$ is red. - In this example, traffic arrives immediately on Academic Ave. Therefore, the controller remains in state $S0$, keeping $L_A$ green even though traffic arrives on Bravado Blvd. and starts waiting. After 15 seconds, the traffic on Academic Ave. has all passes through and $T_A$ falls. At the following clock edge, the controller proceeds to state S2 in which $L_A$ turns red and $L_B$ turns green.  The controller waits in state $S_2$ until all the traffic on Bravado Blvd. has passes through. It then proceeds to state  $S3$, turning $L_B$ yellow. 5 seconds later, the controller enters state $S0$, turning $L_B$ red and $L_A$ green. The process repeats. - \u8be6\u7ec6\u89e3\u91ca\uff1a\u9996\u5148\u6765\u770bCLK,CLK\u4ee55s\u4e3a\u5468\u671f,\u6bcf\u7ecf\u8fc75s\u5c31\u4f1a\u8fce\u6765\u4e00\u4e2aclock edge, \u5c4a\u65f6\u4f1a\u66f4\u65b0\u5f53\u524d\u7684state. \u521d\u59cb\u9636\u6bb5\u4f1a\u6709\u4e00\u4e2aReset, \u8fd9\u4e2aReset\u4e0d\u9700\u8981\u6765\u6df1\u7a76, \u57fa\u672c\u80fd\u591f\u7406\u89e3\u5b83\u4f1a\u628a\u72b6\u6001\u7f6e\u4e3aS0,\u540c\u65f6\u76f8\u5e94\u7684\u706f\u53d8\u6210\u7eff\u8272($L_A$)\u548c\u7ea2\u8272($L_B$).\u5728\u8fd9\u6837\u7684current state\u548cinput\u4e4b\u4e0b, $T_A$\u4fdd\u6301HIGH, \u4f1a\u5bfc\u81f4next state\u4f9d\u7136\u5bf9\u5e94\u7684\u662fS0.      \u7531\u4e8e\u7ecf\u8fc7\u4e00\u5b9a\u7684\u65f6\u95f4(15s)\u4e4b\u540e, $T_A$ \u53d8\u4e3aLOW, \u8fd9\u5bfc\u81f4next state\u7531S0\u53d8\u6210\u4e86S1, \u5728clock edge\u5230\u6765\u7684\u65f6\u5019, current state \u548c\u5f53\u524d\u706f\u7684\u989c\u8272\u90fd\u4f1a\u53d1\u751f\u53d8\u5316(current state\u53d8\u4e3aS1, \u5f53\u524d\u706f\u7684\u989c\u8272\u5206\u522b\u53d8\u4e3a\u4e86\u9ec4\u8272\u548c\u7ea2\u8272), \u6b64\u65f6next state\u4e5f\u4f1a\u968f\u7740current state \u548c input\u7684\u53d8\u5316\u800c\u53d8\u4e3aS2, \u8fd9\u6837\u5728clock edge\u5230\u6765\u7684\u65f6\u5019, current state \u548c\u5f53\u524d\u706f\u7684\u989c\u8272\u90fd\u4f1a\u53d1\u751f\u53d8\u5316(current state\u53d8\u4e3aS2\uff0c\u5f53\u524d\u706f\u7684\u989c\u8272\u5206\u522b\u53d8\u4e3a\u4e86\u7ea2\u8272\u548c\u7eff\u8272).      \u5728\u67d0\u4e00\u4e2a\u65f6\u95f4\u70b9\u4e4b\u540e, $T_B$\u53d8\u4e3aLOW,\u8fd9\u5bfc\u81f4next state\u7531S2\u53d8\u4e3aS3,\u8fd9\u6837\u7b49clock edge\u5230\u6765\u7684\u65f6\u5019, current state \u548c\u5f53\u524d\u706f\u7684\u989c\u8272\u90fd\u4f1a\u53d1\u751f\u53d8\u5316(current state\u53d8\u4e3aS3, \u5f53\u524d\u706f\u7684\u989c\u8272\u5206\u522b\u53d8\u4e3a\u4e86\u7ea2\u8272\u548c\u9ec4\u8272), \u6b64\u65f6next state\u4e5f\u4f1a\u968f\u7740current state \u548c input\u7684\u53d8\u5316\u800c\u53d8\u4e3aS0,\u8fd9\u6837\u5728clock edge\u5230\u6765\u7684\u65f6\u5019, current state \u548c\u5f53\u524d\u706f\u7684\u989c\u8272\u90fd\u4f1a\u53d1\u751f\u53d8\u5316(current state\u53d8\u4e3aS0\uff0c\u5f53\u524d\u706f\u7684\u989c\u8272\u5206\u522b\u53d8\u4e3a\u4e86\u7eff\u8272\u548c\u7ea2\u8272).      ![Screenshot 2023-02-01 at 15.28.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_15.28.36%202.png)      ![Screenshot 2023-02-02 at 17.20.57.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_17.20.57.png)      ![Screenshot 2023-02-02 at 22.50.31.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_22.50.31.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#342-state-encodings","title":"3.4.2 State Encodings","text":"\ud83d\udcd6 **Important takeaways**  - One important decision in **state encoding** is the choice between **binary encoding** and **one-hot encoding**.     - With **binary encoding**, as was used in the traffic light controller example, **each state is represented as a binary number**. Because $K$ binary numbers can be represented by $\\log_2K$ bits, **a system with $K$ states only needs $\\log_2K$ bits of state(more accurately, $\\big\\lceil\\log_2K\\big\\rceil$)**.     - In **one-hot encoding**, **a separate bit of state is used for each state**. It is called one-hot because only one-bit is \u201chot\u201d or TRUE at any time. **For example. a one-hot encoded FSM with three states would have state encodings of 001, 010, and 100**. **Each bit of state is stored in a flip-flop, so one-hot encoding requires more flip-flops than binary encoding**. However, with one-hot encoding, the next-state and output logic is often simpler, so fewer gates are required. The best encoding choice depends on the specific FSM. - one-hot state encoding example(traffic light problem)       | State | one-hot encoding |     | --- | --- |     | S0 | 0001 |     | S1 | 0010 |     | S2 | 0100 |     | S3 | 1000 |      | current state | $T_A$ | $T_B$ | next state |     | --- | --- | --- | --- |     | S0 | 0 | X | S1 |     | S0 | 1 | X | S0 |     | S1 | X | X | S2 |     | S2 | X | 0 | S3 |     | S2 | X | 1 | S2 |     | S3 | X | X | S0 |  ![Screenshot 2023-02-05 at 09.24.35.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_09.24.35.png)  ![Screenshot 2023-02-05 at 09.25.25.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_09.25.25.png)  ![Screenshot 2023-02-05 at 09.49.07.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_09.49.07.png)  | $S_3$ | $S_2$ | $S_1$ | $S_0$ | $T_A$ | $T_B$ | $S_3^\\prime$ | $S_2^\\prime$ | $S_1^\\prime$ | $S_0^\\prime$ | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | | 0 | 0 | 0 | 1 | 0 | X | 0 | 0 | 1 | 0 | | 0 | 0 | 0 | 1 | 1 | X | 0 | 0 | 0 | 1 | | 0 | 0 | 1 | 0 | X | X | 0 | 1 | 0 | 0 | | 0 | 1 | 0 | 0 | X | 0 | 1 | 0 | 0 | 0 | | 0 | 1 | 0 | 0 | X | 1 | 0 | 1 | 0 | 0 | | 1 | 0 | 0 | 0 | X | X | 0 | 0 | 0 | 1 |  | $S_3$ | $S_2$ | $S_1$ | $S_0$ | $L_{A1}$ | $L_{A0}$ | $L_{B1}$ | $L_{B0}$ | | --- | --- | --- | --- | --- | --- | --- | --- | | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | | 0 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | - **Common Error(!!!)**     - **Incorrect Version**          $$         S_3^\\prime=\\overline{S_3}S_2\\overline{S_1}\\,\\overline{S_0}\\,\\overline{T_B}         $$      - **Correct Version**           $$         S_3^\\prime=S_2\\overline{T_B}         $$          $$         S_2^\\prime=S_1+S_2T_B         $$          $$         S_1^\\prime=S_0\\overline{T_A}         $$          $$         S_0^\\prime=S_0T_A+S_3         $$          $$         L_{A1}=S_2+S_3         $$          $$         L_{A0}=S_1         $$          $$         \u204d         $$          $$         L_{B_0}=S_3         $$          \u8fd9\u6837\u505a\u7684\u539f\u56e0\u662f\u5728one-hot encoding\u4e2d\uff0c\u5982\u679c\u6709\u4e00\u9879\u88ab\u8bbe\u5b9a\u4e3aHIGH\uff0c\u53731\uff0c\u5176\u5b83\u51e0\u9879\u5c31\u81ea\u52a8\u4e3a0\u4e86\uff0c\u8fd9\u662fone-hot encoding\u7684\u5b9a\u4e49\u6240\u51b3\u5b9a\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u4e0d\u9700\u8981\u8bf8\u5982$\\overline{S_3}$, $\\overline{S_1}$, $\\overline{S_0}$\u7b49\u9879\u3002  - \u53c2\u8003\u7535\u8def\u56fe       ![Screenshot 2023-02-05 at 09.57.09.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_09.57.09.png)      - \u5728\u5de6\u4fa7\u7684\u7535\u8def\u56fe\u4e2d\u6709\u4e00\u4e2a\u95ee\u9898\uff0c\u5f53Reset=1\u65f6\uff0c\u9ed8\u8ba4$S_3,S_2,S_1,S_0$\u90fd\u88ab\u7f6e\u4e3a0\uff0c\u4f46\u662f0000\u5e76\u4e0d\u5bf9\u5e94\u6211\u4eec\u60f3\u8981\u7684\u521d\u59cb\u72b6\u6001S0,\u56e0\u4e3a\u5728one-hot encoding\u4e2d\uff0c\u521d\u59cb\u72b6\u6001S0\u5bf9\u5e94\u7684\u662f0001\u3002     - \u6539\u8fdb\u7684\u65b9\u6cd5\u5c31\u662f\u8ba9\u524d\u4e09\u4e2a\u90fd\u662fresettable flip-flop\uff0c\u800c\u628a\u6700\u4e0b\u9762\u7684\u4e00\u4e2a\u6362\u6210settable flip-flop\u3002"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#343-moore-and-mealy-machines","title":"3.4.3 Moore and Mealy Machines","text":"\ud83d\udcd6 **Important takeaways**  - So far, we have shown examples of Moore machines, in which the output depends only on the state of the system. Hence, in state transition diagrams for Moore machines, the outputs are labeled in the circles. - Recall that Mealy machines are much like Moore machines, but the outputs can depend on inputs as well as the current state. Hence, in state transition diagrams for Mealy machines, the outputs are labeled on the arcs instead of in the circles. - The block of combinational logic that computes the outputs uses the current state and inputs, as was shown in Figure 3.22(b).  ![Screenshot 2023-02-02 at 10.01.57.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-02_at_10.01.57.png)  ![Screenshot 2023-02-01 at 15.28.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-01_at_15.28.36.png)  ![Screenshot 2023-02-05 at 10.23.38.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_10.23.38.png)  ![Screenshot 2023-02-05 at 10.24.08.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_10.24.08.png)  - **Moore FSM**     - \u5bf9\u4e8e\u8fd9\u6837\u4e00\u4e2a\u95ee\u9898\uff0c\u9996\u5148\u6211\u4eec\u8981\u505a\u7684\u4e5f\u662f\u753b\u51faFSM\u7684state transition diagram\u3002\u9996\u5148\u5728Reset\u4e4b\u540e\uff0c\u8fdb\u5165\u5230\u4e86S0\u72b6\u6001\uff0cS0\u72b6\u6001\u8bf4\u767d\u4e86\u5c31\u662f\u4e00\u7247\u7a7a\u767d\uff0c\u6ca1\u6709\u4efb\u4f55\u6211\u4eec\u60f3\u8981\u7684\u5e8f\u5217\u3002\u8fdb\u5165\u5230\u4e86S0\u72b6\u6001\u540e\uff0c\u5982\u679c\u5f53\u524d\u7684\u8f93\u5165\u662f0\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u7531S0\u72b6\u6001\u8fdb\u5165\u5230\u4e86S1\u72b6\u6001\uff0c\u6211\u4eec\u73b0\u5728\u6512\u591f\u4e86\u76ee\u680701\u4e2d\u7684\u7b2c\u4e00\u4e2a\u6570\u5b570\uff0c\u5982\u679c\u5728\u8fdb\u5165\u5230S0\u72b6\u6001\u4e4b\u540e\uff0c\u5f53\u524d\u8f93\u5165\u7684\u6570\u5b57\u662f1\uff0c\u90a3\u4e48\u6211\u4eec\u4f9d\u7136\u505c\u7559\u5728S0\u72b6\u6001\uff0c\u56e0\u4e3a\u6211\u4eec\u7684\u76ee\u6807\u5e8f\u5217\u662f01\uff0c\u5f53\u524d\u5355\u72ec\u7ed9\u4e00\u4e2a1\uff0c\u5e76\u4e14\u5728\u8fd9\u4e2a1\u524d\u5e76\u6ca1\u67090\u662f\u6beb\u65e0\u610f\u4e49\u7684\uff0c\u6211\u4eec\u4f9d\u7136\u6ca1\u6709\u4f5c\u51fa\u4efb\u4f55\u6709\u6548\u7684\u63a8\u8fdb\u5de5\u4f5c\uff0c\u6240\u4ee5\u505c\u7559\u5728S0\u7684\u72b6\u6001\u3002     - \u5f53\u6211\u4eec\u8fdb\u5165\u5230S1\u72b6\u6001\u540e\uff0c\u5982\u679c\u5f53\u524d\u7684\u8f93\u5165\u662f1\uff0c\u90a3\u4e48\u5f88\u597d\uff0c\u6211\u4eec\u5df2\u7ecf\u51d1\u591f\u4e8601\u4e24\u4e2a\u5e8f\u5217\u8fdb\u5165\u5230S2\u72b6\u6001\uff0cS2\u72b6\u6001\u662f1\uff0c\u610f\u5473\u7740\u7b26\u5408\u8981\u6c42\uff0c\u6b64\u65f6\u53ef\u4ee5\u8f93\u51fa\ud83d\ude0a\u3002\u800c\u5f53\u6211\u4eec\u8fdb\u5165\u5230S1\u72b6\u6001\u540e\uff0c\u5982\u679c\u5f53\u524d\u7684\u8f93\u5165\u662f0\uff0c\u90a3\u4e48\u6211\u4eec\u4e0d\u4f1a\u8fdb\u5165\u5230S2\u72b6\u6001\uff0c\u4f9d\u7136\u505c\u7559\u5728S1\u72b6\u6001\uff0c\u5373\u6211\u4eec\u6709\u6548\u7684\u6570\u5b57\u4f9d\u7136\u53ea\u670901\u4e2d\u76840\uff0c\u8fd8\u7f3a1\u4e2a1\u3002     - \u8fdb\u5165\u5230S2\u72b6\u6001\u540e\uff0c\u5982\u679c\u5f53\u524d\u7684\u8f93\u5165\u662f1\uff0c\u6211\u4eec\u4f1a\u9000\u56deS0\u8fd9\u4e2a\u4e00\u7a77\u4e8c\u767d\u7684\u72b6\u6001\u3002\u5982\u679c\u5f53\u524d\u7684\u8f93\u5165\u662f0\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u5df2\u7ecf\u6512\u591f\u4e86\u4e00\u4e2a\u65b0\u768401\u5e8f\u5217\u4e2d\u7684\u7b2c\u4e00\u4e2a\u6570\u5b570\uff0c\u56e0\u6b64\u6211\u4eec\u53c8\u4e00\u6b21\u8fdb\u5165\u5230\u4e86S1\u72b6\u6001\uff0c\u8fd9\u4fbf\u662f\u5bf9\u4e8eMoore FSM state transition diagram\u7684\u89e3\u91ca\u3002     - \u800c\u5bf9\u4e8eMealy FSM\u800c\u8a00\uff0c\u5728arc\u4e0a\u9075\u5faa\u7684\u662finput/output\u7684\u683c\u5f0f\uff0c\u4f8b\u5982\u5f53\u524d\u82e5\u5904\u4e8eS0\u72b6\u6001\uff0c\u82e5\u8f93\u5165\u662f0\uff0c\u5219\u8fdb\u5165S1\u72b6\u6001\uff0c\u8f93\u51fa\u4e3a0\uff0c\u56e0\u6b64\u4eceS0\u5230S1\u6709\u4e00\u4e2aarc\uff0c\u4e0a\u9762\u5199\u77400/0\u3002\u5f53\u524d\u82e5\u5904\u4e8eS0\u72b6\u6001\uff0c\u82e5\u8f93\u5165\u662f1\uff0c\u5219\u4ecd\u7136\u505c\u7559\u5728S0\u72b6\u6001\uff0c\u8f93\u51fa\u4e3a0\uff0c\u56e0\u6b64\u4eceS0\u5230S0\u6709\u4e00\u4e2aarc\uff0c\u4e0a\u9762\u5199\u77400/0\u3002\u5f53\u524d\u82e5\u5904\u4e8eS1\u72b6\u6001\uff0c\u82e5\u8f93\u5165\u4e3a1\uff0c\u5219\u8f93\u51fa\u4e3a1\uff0c\u540c\u65f6\u56de\u9000\u5230S0\u7684\u72b6\u6001\uff0c\u56e0\u6b64\u4eceS1\u5230S0\u6709\u4e00\u4e2aarc\uff0c\u4e0a\u9762\u5199\u77401/1\u3002\u5f53\u524d\u82e5\u5904\u4e8eS1\u72b6\u6001\uff0c\u82e5\u8f93\u5165\u4e3a0\uff0c\u5219\u8f93\u51fa\u4e3a0\uff0c\u540c\u65f6\u4f9d\u7136\u505c\u7559\u5728S1\u7684\u72b6\u6001\uff0c\u56e0\u6b64\u4eceS1\u5230S1\u6709\u4e00\u4e2aarc\uff0c\u4e0a\u9762\u5199\u77400/0\u3002     - \u6211\u4eec\u63a5\u4e0b\u6765\u8fd8\u662f\u6765\u5199\u51faMoore FSM\u7684state transition table\uff0c\u5bf9\u4e8estate encoding\uff0c\u6211\u4eec\u91c7\u53d6\u5982\u4e0b\u7684\u683c\u5f0f\uff0cS0: 00, S1: 01, S2: 10, \u6211\u4eec\u91c7\u7528\u7684\u662fbinary encoding, \u6ca1\u6709\u91c7\u7528one-hot encoding\u6cd5\u3002           | $S_1$ | $S_0$ | Inputs(A) | $S_1^\\prime$ | $S_0^\\prime$ |         | --- | --- | --- | --- | --- |         | 0 | 0 | 0 | 0 | 1 |         | 0 | 0 | 1 | 0 | 0 |         | 0 | 1 | 0 | 0 | 1 |         | 0 | 1 | 1 | 1 | 0 |         | 1 | 0 | 0 | 0 | 1 |         | 1 | 0 | 1 | 0 | 0 |          $$         \\begin{align*}S_1^\\prime&amp;=\\overline{S_1}S_0A\\\\S_0^\\prime&amp;=\\overline{A}\\end{align*}         $$          \u5982\u4f55\u5f97\u5230$S_0^\\prime=\\overline{A}$\uff0c\u4e00\u65b9\u9762\u53ef\u4ee5\u901a\u8fc7\u89c2\u5bdfstate transition table\u5f97\u51fa\u7ed3\u8bba\uff0c\u53e6\u4e00\u65b9\u9762\u53ef\u4ee5\u901a\u8fc7Karnaugh map\u5f97\u51fa\u7ed3\u8bba\u3002          | $A/S_1S_0$ | 00 | 01 | 11 | 10 |         | --- | --- | --- | --- | --- |         | 0 | 1 | 1 | X | 1 |         | 1 | 0 | 0 | X | 0 |     - \u5728\u5f97\u5230Moore FSM\u7684state transition table\u540e\uff0c\u6211\u4eec\u4e0b\u4e00\u6b65\u7684\u4efb\u52a1\u5c31\u662f\u753b\u51faoutput table\u3002           | $S_1$ | $S_0$ | output(Y) |         | --- | --- | --- |         | 0 | 0 | 0 |         | 0 | 1 | 0 |         | 1 | 0 | 1 |          $$         Y=S_1         $$   - **Mealy FSM**     - **Mealy transition &amp; output table**          \u5bf9\u4e8eMealy FSM\u6765\u8bf4\uff0c\u5176transition table\u548coutput table\u662f\u753b\u5728\u4e00\u8d77\u7684\u3002\u7279\u522b\u6ce8\u610f\uff0c\u76f8\u6bd4\u4e8eMoore FSM\uff0c\u5728\u8fd9\u4e2a\u5177\u4f53\u7684\u95ee\u9898\u4e2dMealy FSM\u7684state\u53d8\u6210\u4e862\uff0c\u6bd4Moore FSM\u5c11\u4e00\u4e2a\uff0c\u56e0\u6b64\u53ea\u9700\u89811 bit\u5373\u53ef\u8868\u793a\uff0c\u4e0d\u9700\u89812 bits\u3002            | $S_0$ | input(A) | $S_0^\\prime$ | output(Y) |         | --- | --- | --- | --- |         | 0 | 0 | 1 | 0 |         | 0 | 1 | 0 | 0 |         | 1 | 0 | 1 | 0 |         | 1 | 1 | 0 | 1 |          $$         \\begin{align*}S_0^\\prime&amp;=\\overline{S_0}\\,\\overline{A}+S_0\\overline{A}=\\overline{A}\\\\Y&amp;=S_0A\\end{align*}         $$   ![Screenshot 2023-02-05 at 11.47.16.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_11.47.16.png)  ![Screenshot 2023-02-05 at 11.45.43.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_11.45.43.png)  ![Screenshot 2023-02-05 at 11.24.50.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_11.24.50.png)  ![Screenshot 2023-02-05 at 11.47.48.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_11.47.48.png)  ![Screenshot 2023-02-05 at 11.45.54.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_11.45.54.png)  ![Screenshot 2023-02-05 at 11.25.12.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_11.25.12.png)  ![Screenshot 2023-02-05 at 11.43.29.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_11.43.29.png)  ![Screenshot 2023-02-05 at 11.44.10.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_11.44.10.png)  - The Moore and Mealy machine schematics are shown in Figure 3.31. The timing diagrams for each machine are shown in Figure 3.32. The two machines follow a different sequence of states. Moreover, **the Mealy machine\u2019s output rises a cycle sooner because it responds to the input rather than waiting for the state change**. If the Mealy output was delayed through a flip-flop, it would match the Moore output. When choosing your FSM design style, consider when you want your outputs to respond. - \u80cc\u540e\u7684\u903b\u8f91\u5c31\u662f\u5f53\u8f93\u5165\u75310\u8f6c1\u7684\u65f6\u5019\uff0cMoore FSM\u5fc5\u987b\u7b49\u5f85\u4e0b\u4e00\u4e2aclock edge\u8f6c\u53d8\u4e3astate S2\u7684\u65f6\u5019\u624d\u4f1a\u8f93\u51fa1\uff0c\u4f46\u662fMealy FSM\u5229\u7528state S1\u548c\u521a\u521a\u75310\u8f6c1\u7684\u8f93\u5165\u76f4\u63a5\u5c31\u53ef\u4ee5\u8fdb\u884c\u8f93\u51fa\uff0c\u56e0\u6b64Mealy FSM\u76f8\u8f83Moore FSM\u8f93\u51fa\u63d0\u524d\u3002 - \u5982\u679c\u5f53input\u53d1\u751f\u53d8\u5316\u540e\uff0c\u6211\u4eec\u8981\u6c42output\u65e0\u5ef6\u8fdf\u7acb\u523b\u8ddf\u968f\u5176\u4f5c\u51fa\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u4f7f\u7528Mealy FSM\u3002"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#35-timing-of-sequential-logic","title":"3.5 Timing of Sequential Logic","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#350-timing-of-sequential-logic","title":"3.5.0 Timing of Sequential Logic","text":"\ud83d\udcd6 **Background**  - Recall that a flip-flop copies the input $D$ to the output $Q$ on the rising edge of the clock. This process is called **sampling $D$ on the clock edge**. If $D$ is stable at either 0 or 1 when the clock rises, this behavior is clearly defined. But what happens if $D$ is changing at the same time the clock rises? - This problem is similar to that faced by a camera when snapping a picture. Imagine photographing a frog jumping from a lily pad into a lake. If you take the picture before the jump, you will see a frog on a lily pad(stable). If you take the picture after the jump, you will see ripples in the water(stable). But if you take it just as the frog jumps, you may see a blurred image of the frog stretching from the lily pad into the water. - A camera is characterized by its aperture time, during which the object must remain still for a sharp image to be captured. Similarly, a sequential element has an aperture time around the clock edge, during which the input must be stable for the flip-flop to produce a well-defined output. - The aperture of a sequential element is defined by a setup time and a hold time, before and after the clock edge, respectively. Just as the static discipline limited us to using logic levels outside the forbidden zone, the dynamic discipline limits us to using signals that change outside the aperture time. - By taking advantage of the dynamic discipline, we can think of time in discrete units called clock cycles, just as we think of signal levels as discrete 1\u2019s and 0\u2019s. A signal may glitch and oscillate wildly for some bounded amount of time. Under the dynamic discipline, we are concerned only about its final value at the end of the clock cycle, after it has settled to a stable value. Hence, we can simply write $A[n]$, the value of signal $A$ at the end of the $n\\mathrm{th}$ clock cycle, where $n$ is an integer, rather than $A(t)$, the value of $A$ at some instant $t$, where $t$ is any real number. - The clock period has to be long enough for all signals to settle. This sets a limit on the speed of the system. In real systems, the clock does not reach all flip-flops at precisely the same time. This variation in time, called clock skew, further increases the necessary clock period. - Sometimes it is impossible to satisfy the dynamic discipline, especially when interfacing with the real world. For example, consider a circuit with an input coming from a button. A monkey might press the button just as the clock rises. This can result in a phenomenon called metastability, where the flip-flop captures a value partway between 0 and 1 that can take an unlimited amount of time to resolve into a good logic value. The solution to such asynchronous inputs is to use a synchronizer, which has a very small(but nonzero) probability of producing an illegal logic value. - We expand on all of these ideas in the rest of this section."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#351-the-dynamic-discipline","title":"3.5.1 The Dynamic Discipline","text":"\ud83d\udcd6 **Important takeaways(From the video lecture)**  - Synchronous sequential circuit inputs must be stable during aperture(setup and hold) time around clock edge. - Specifically, inputs must be stable     - at least $t_{setup}$ before the clock edge     - at least until $t_{hold}$ after the clock edge - The delay between registers has a minimum and maximum delay, dependent on the delays of the circuit elements.     - minimum delay $=t_{ccq}+t_{cd}+t_{setup}$.     - maximum delay $=t_{pcq}+t_{pd}+t_{setup}$.      ![Screenshot 2023-02-05 at 21.02.00.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_21.02.00.png)      ![Screenshot 2023-02-05 at 21.04.14.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_21.04.14.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#352-system-timing","title":"3.5.2 System Timing(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - **Clock period(cycle time)**     - The clock period or cycle time, $T_c$, is the time between rising edges of a repetitive clock signal. Its reciprocal, $f_c=1/T_c$, is the clock frequency.     - All else being the same, increasing the clock frequency increases the work that a digital system can accomplish per unit time.     - Frequency is measured in units of Hertz(Hz), or cycles per second: 1 megahertz(MHz) = $10^6$ Hz, and 1 gigahertz(GHz) = $10^9$ Hz.     - Figure 3.38(a) illustrates a generic path in a synchronous sequential circuit whose clock period we wish to calculate. On the rising edge of the clock, register R1 produces output(or outputs) Q1. These signals enter a block of combinational logic, producing D2, the input(or inputs) to register R2.     - The timing diagram in Figure 3.38(b) shows that each **output signal may start to change a contamination delay after its input changes** and **settles to the final value within a propagation delay after its input settles**.     - The **gray arrows** represent **the contamination delay through R1 and the combinational logic**, and the **blue arrows** represent **the propagation delay through R1 and the combinational logic**.     - We analyze the timing constraints with respect to the setup and hold time of the second register, R2.      ![Screenshot 2023-02-05 at 18.09.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_18.09.36.png)   - **Setup Time Constraints(also called cycle time constraints)**     - Depends on the maximum delay from register R1 through combinational logic to R2.     - The input to register R2 must be stable at least $t_{setup}$ before clock edge.      $$     T_c\\ge t_{pcq}+t_{pd}+t_{setup}     $$      $$     t_{pd}\\le T_c-(t_{pcq}+t_{setup})     $$      - $t_{pcq}+t_{setup}$ is called the sequencing overhead.      ![Screenshot 2023-02-05 at 21.08.08.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_21.08.08.png)      - Figure 3.39 is the timing diagram showing only the maximum delay through the path, indicated by the blue arrows. To satisfy the setup time of R2, D2 must settle no later than the setup time before the next clock edge.     - Hence, we find an equation for the minimum clock period:          $$         T_c\\ge t_{pcq}+t_{pd}+t_{setup}         $$      - In commercial designs, the clock period is often dictated by the Director of Engineering or by the marketing department(to ensure a competitive product). Moreover, the flip-flop clock-to-Q propagation delay and setup time, $t_{pcq}$ and $t_{setup}$, are specified by the manufacturer. Hence, we rearrange the equation above to solve for **the maximum propagation delay through the combinational logic($t_{pd}$), which is usually the only variable under the control of the individual designer**.          $$         t_{pd}\\le T_c-(t_{pcq}+t_{setup})\\,\\,\\,(3.14)         $$      - The term in parentheses, $t_{pcq}+t_{setup}$, is called the sequencing overhead. **Ideally**, the entire cycle time $T_c$ would be available for useful computation in the combinational logic, $t_{pd}$. **However, the sequencing overhead of the flip-flop cuts into this time**. Equation 3.14 is called the setup time constraint or max-delay constraint, because it depends on the setup time and limits the maximum delay through the combinational logic.     - If the propagation delay through the combinational logic($t_{pd}$) is too great, D2 may not have settled to its final value by the time R2 needs it to be stable and samples it(\u7a33\u5b9a\u4e0b\u6765\u7684\u65f6\u95f4\u5728$t_{setup}$\u4e4b\u540e\uff0c\u8fd9\u662f\u4e0d\u88ab\u5141\u8bb8\u7684\uff0c\u5fc5\u987b\u81f3\u5c11\u5728\u4e0b\u4e00\u4e2aclock edge\u524d\u7684$t_{setup}$\u5c31\u4fdd\u6301\u7a33\u5b9a). Hence, R2 may sample an incorrect result or even an illegal logic level, a level in the forbidden region. In such a case, the circuit will malfunction. The problem can be solved by increasing the clock period(\u589e\u5927$\\,T_c\\,$) or by redesiging the combinational logic to have a shorter propagation delay.      ![Screenshot 2023-02-05 at 21.30.35.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_21.30.35.png)   - **Hold Time Constraints**     - Depends on the minimum delay from register R1      - The register R2 in Figure 3.38(a) also has a hold time constraint. Its input D2, must not change until some time, $t_{hold}$, after the rising edge of the clock. According to Figure 3.40, D2 might change as soon as $t_{ccq}+t_{cd}$ after the rising edge of the clock. Hence, we find          $$         t_{ccq}+t_{cd}\\ge t_{hold}         $$      - Again, $t_{ccq}$ and $t_{cd}$ are characteristics of the flip-flop that are usually outside the designer\u2019s control. Rearranging, we can solve for the minimum contamination dealy through the combinational logic  - **Input Timing Constraints**     - Setup time: $t_{setup}=$ time before clock edge data must be stable     - Hold time: $t_{hold}=$ time after clock edge data must be stable     - Aperture time: $t_a=$ time around clock edge data must be stable          $$         t_a=t_{setup}+t_{hold}         $$  - \u5177\u4f53\u6765\u8bb2\uff0c\u8fd9\u4e9binput timing constraints\u5728\u5fae\u89c2\u4e0a\u5230\u5e95\u6765\u6e90\u4e8e\u4ec0\u4e48\u5462\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u5c55\u5f00\u6765\u770bD flip-flop\u7684\u5fae\u89c2\u7ed3\u6784\u3002\u4e00\u4e2aD flip-flop\u662f\u7531\u4e24\u4e2aD latch\u7ec4\u6210\u7684\uff0c\u5f53CLK=0\u65f6\uff0c\u5de6\u8fb9\u7684master D latch\u662f\u5904\u5728transparent\u7684\u72b6\u6001\uff0c\u800c\u53f3\u4fa7\u7684slave D latch\u662f\u5904\u5728opaque\u7684\u72b6\u6001\uff0c\u6b64\u65f6D\u7684\u4fe1\u53f7\u53ef\u4ee5\u901a\u8fc7master D latch\u4f20\u9001\u5230N1\u7684\u4f4d\u7f6e\uff0c\u4f46\u7531\u4e8e\u53f3\u4fa7\u7684slave D latch\u662f\u5904\u5728opaque\u7684\u72b6\u6001\uff0cN1\u4fe1\u53f7\u65e0\u6cd5\u901a\u8fc7\u53f3\u4fa7\u7684slave D latch\u4f20\u9012\u5230Q\u3002\u56e0\u6b64\u6211\u4eec\u8bf4$\\,t_{setup}\\,$\u672c\u8d28\u4e0a\u5c31\u5bf9\u5e94\u7740\u4fe1\u53f7\u5728clock edge\u53d1\u751f\u4ee5\u524d\u4fe1\u53f7\u4ece$\\,D\\,$\u4f20\u5bfc\u5230\u4e2d\u95f4\u7684N1\u7684\u8fc7\u7a0b\u3002\u56e0\u4e3a\u5982\u679c\u4fe1\u53f7\u5728clock edge\u4e4b\u524d\u4e00\u76f4\u90fd\u5904\u4e8e\u6ce2\u52a8\u72b6\u6001\uff0c\u4e2d\u95f4\u7684N1\u5904\u63a5\u6536\u5230\u7684\u4fe1\u53f7\u5904\u4e8e\u6ce2\u52a8\u4e0d\u89c4\u5f8b\u7684\u72b6\u6001\uff0c\u90a3\u4e48\u6211\u4eec\u6700\u7ec8\u83b7\u5f97\u7684\u4fe1\u53f7\u4e5f\u4e00\u5b9a\u4e0d\u4f1a\u662f\u6211\u4eec\u60f3\u8981\u7684\u3002 - \u5f53clock edge\u53d1\u751f\u7684\u65f6\u5019\uff0cCLK\u4f1a\u75310\u53d8\u4e3a1\uff0c\u6b64\u65f6\u53f3\u4fa7\u7684slave D latch\u5904\u5728transparent\u7684\u72b6\u6001\uff0c\u4e2d\u95f4\u7684internal node N1\u5904\u7684\u4fe1\u53f7\u4f1a\u901a\u8fc7\u53f3\u4fa7\u7684slave D latch\u4f20\u9012\u5230Q\u5904\u3002\u4f46\u662f\u7531\u4e8e\u5de6\u4fa7\u7684\u5206\u652f\u6709\u4e00\u4e2ainverter\uff0c\u800c\u8fd9\u4e2ainverter\u5b58\u5728\u5ef6\u65f6\uff0c\u4e5f\u5c31\u662f\u8bf4\u5f53clock edge\u5230\u6765\u7684\u65f6\u5019\uff0cCLK\u75310\u53d8\u4e3a1\uff0c\u4f46\u662f\u5de6\u4fa7\u5206\u652f\u5e76\u4e0d\u662f\u7acb\u523b\u75311\u53d8\u4e3a0\uff0c\u4e2d\u95f4\u7ecf\u5386\u4e86\u77ed\u6682\u7684\u65f6\u95f4\u624d\u4f1a\u75311\u53d8\u4e3a0\uff0c\u800c\u5728\u8fd9\u4e2a\u77ed\u6682\u7684\u65f6\u95f4\u95f4\u9694\u4e4b\u5185\uff0c\u5de6\u4fa7\u7684master D latch\u5176\u5b9e\u8fd8\u5904\u4e8e\u77ed\u6682\u7684transparent\u7684\u72b6\u6001\uff0c\u4e5f\u5c31\u662f\u8bf4D\u5904\u7684\u4fe1\u53f7\u4ecd\u80fd\u5728\u8fd9\u4e2a\u65f6\u95f4\u95f4\u9699\u4e2d\u901a\u8fc7master D latch\u5230\u8fbe\u4e2d\u95f4\u7684N1\uff0c\u540c\u65f6\u901a\u8fc7\u53f3\u4fa7\u7684slave D latch\u6700\u7ec8\u4f20\u9001\u5230Q\uff0c\u90a3\u4e48\u5728\u8fd9\u4e2a\u77ed\u6682\u7684\u65f6\u95f4$\\,t_{hold}\\,$\u5185\uff0c\u6211\u4eec\u8981\u6c42\u4fe1\u53f7\u5fc5\u987b\u4fdd\u6301\u7a33\u5b9a\uff0c\u56e0\u4e3aD\u4ecd\u7136\u5904\u5728sampling\u7684\u72b6\u6001\u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u8bf4$\\,t_{hold}\\,$\u5728\u5fae\u89c2\u7535\u8def\u4e2d\u5bf9\u5e94\u7684\u5176\u5b9e\u662finverter\u7684\u5ef6\u65f6(delay)\u3002  ![Screenshot 2023-02-05 at 14.43.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_14.43.36.png)  ![Screenshot 2023-02-05 at 14.47.48.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_14.47.48.png)  - **Output Timing Constraints**     - Propagation delay: $t_{pcq}=$ time after the clock edge that $Q$ is guaranteed to be stable(i.e., to stop changing): maximum delay. \u4ececlock\u7684change\u5230Q\u7684change\u4e4b\u95f4\u7ecf\u5386\u7684\u6700\u957f\u7684\u65f6\u95f4\u957f\u5ea6(Q change\u6700\u665a\u65f6\u95f4)\u3002     - Contamination delay: $t_{ccq}=$ time after the clock edge that $Q$ might be unstable(i.e., start changing): minimum delay.\u4ececlock\u7684change\u5230Q\u7684change\u4e4b\u95f4\u7ecf\u5386\u7684\u6700\u77ed\u7684\u65f6\u95f4\u957f\u5ea6(Q change\u6700\u65e9\u65f6\u95f4)     - \u5f53\u51fa\u73b0clock edge\u7684\u65f6\u5019\uff0cQ\u5904\u7684\u8f93\u51fa\u7ed3\u679c\u4f1a\u88ab\u66f4\u65b0\uff0cQ\u5904\u7684\u8f93\u51fa\u7ed3\u679c\u6765\u6e90\u4e8einternal node N1\uff0c\u4f46\u662fN1\u7684\u4fe1\u53f7\u4f20\u5230Q\u5904\u9700\u8981\u65f6\u95f4\uff0c\u56e0\u4e3a\u4eceN1\u5230Q\u4e2d\u95f4\u8fd8\u9694\u7740\u4e00\u4e2aL2 slave latch\uff0c\u8fd9\u4e2aslave latch\u5b58\u5728delay\uff0c\u8fd9\u4e24\u79cddelay\u53ef\u4ee5\u88ab\u8ba4\u4e3a\u6210\u662fslave D latch(L2)\u7684\u6700\u957f\u5ef6\u65f6\u4e0e\u6700\u77ed\u5ef6\u65f6\u3002     - \u5728$\\,t_{ccq}\\,$\u548c$\\,t_{pcq}\\,$\u4e4b\u95f4, Q\u7684\u4fe1\u53f7\u4f1a\u53d1\u751f\u6ce2\u52a8\u53d8\u5316\u3002\u800c\u5728$\\,t_{ccq}\\,$\u548c$\\,t_{pcq}\\,$\u4e4b\u5916, Q\u7684\u4fe1\u53f7\u4e0d\u4f1a\u53d1\u751f\u6ce2\u52a8\u53d8\u5316\u3002     - When the clock rises, the output(or outputs) may start to change after the clock-to-Q contamination delay, $t_{ccq}$, and must definitely settle to the final value within the clock-to-Q propagation delay, $t_{pcq}$. These represent the fastest and slowest delays throught the circuit, respectively.  ![Screenshot 2023-02-05 at 16.21.10.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_16.21.10.png)  ![Screenshot 2023-02-05 at 16.21.46.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-05_at_16.21.46.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#5-digital-building-blocks","title":"5 Digital Building Blocks","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#51-introduction","title":"5.1 Introduction","text":"\ud83d\udcd6 **Background**  - Up to this point, we have examined the design of combinational and sequential circuits using Boolean equations, schematics, and HDLs. - This chapter introduces **more elaborate combinational and sequential building blocks** used in digital systems. - These blocks include **arithmetic circuits**, **counters**, **shift registers**, **memory arrays**, and **logic arrays**. - These building blocks are not only useful in their own right, but they also demonstrate the principles of hierarchy, modularity, and regularity. - The building blocks are hierarchically assembled from simpler components such as logic gates, multiplexers, and decoders. - Each building block has a well defined interface and can be treated as a black box when the underlying implementation is unimportant. - The regular structure of each building block is easily extended to different sizes. - In Chapter 7, we use many of these building blocks to build a microprocessor.  ![Screenshot 2023-02-06 at 07.00.06.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_07.00.06.png)  ![Screenshot 2023-02-06 at 07.01.39.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_07.01.39.png)  &gt; Digital circuits such as logic gates restrict the voltages to discrete ranges, which we will use to indicate 0 and 1. In **logic** design, we build **more complex structures**, such as adders or memories, **from digital circuits**. &gt;   &gt; **Microarchitecture links the logic and architecture levels of abstraction**. The architecture level of abstraction describes a computer from a programmer\u2019s perspective. For example, the Intel x86 architecture used by microprocessors in most personal computer(PCs) is defined by a set of instructions and registers(memory for temporarily storing values) that the programmer is allowed to use. **Microarchitecture involves combining logic elements to execute the instructions defined by the architecture**. A particular architecture can be implemented by one of many different microarchitecture with different price/performance/power trade-offs. For example, the Intel Core i7, the Intel 80486, and the AMD Athlon all implement the x86 architecture with different microarchitectures. &gt;"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#52-arithmetic-circuits","title":"5.2 Arithmetic Circuits","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#520-background","title":"5.2.0 Background(!!!)","text":"\ud83d\udcd6 **Background**  - **Arithmetic circuits are the central building blocks of computers**. - Computers and digital logic perform many arithmetic functions:     1. addition     2. subtraction     3. comparisons     4. shifts     5. multiplication     6. division - This section describes hardware implementation for all of these operations."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#521-addition","title":"5.2.1 Addition(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - **Addition is one of the most common operations in digital systems**. We first consider how to **add two 1-bit binary numbers**. We then extend to **N-bit binary numbers**. Adders also illustrate **trade-offs between speed and complexity**.  - **Half Adder(!!!)**     - We begin by building a 1-bit half adder. As shown in Figure 5.1, the half adder has two inputs, A and B, and **two outputs**, $S$, and $C_{out}$.     - $S$ is the sum of A and B. If A and B are both 1, $S$ is 2, **which cannot be represented with a single binary digit**. Instead, it is **indicated with a carry out $C_{out}$ in the next column**. The half adder can be built from an XOR gate and an AND gate.     - In a multi-bit adder, $C_{out}$ is added or carried in to the next most significant bit. For example, in Figure 5.2, the carry bit shown in blue is the output $C_{out}$ of the first column of 1-bit addition and the input $C_{in}$ to the second column of addition.     - However, the half adder lacks a $C_{in}$ input to accept $C_{out}$ of the previous column. The full adder, described in the next section, solves this problem.     - \u6ce8\u610f\u8fd9\u91cc\u89e3\u51b3\u6b64\u7c7b\u95ee\u9898\u7684\u901a\u7528\u65b9\u6cd5\u5c31\u662f\u5199\u51fatruth table\uff0c\u7136\u540e\u6839\u636etruth table\u5199\u5bf9\u5e94\u7684Boolean equations\u3002      $$     \\begin{align*}S&amp;=A\\oplus B\\\\C_{out}&amp;=AB\\end{align*}     $$   ![Screenshot 2023-02-06 at 07.22.46.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_07.22.46.png)  ![Screenshot 2023-02-06 at 07.22.59.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_07.22.59.png)  | A | B | $S$ | $C_{out}$ | | --- | --- | --- | --- | | 0 | 0 | 0 | 0 | | 0 | 1 | 1 | 0 | | 1 | 0 | 1 | 0 | | 1 | 1 | 0 | 1 |  - **Full Adder(!!!)**  ![Screenshot 2023-02-06 at 08.33.27.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_08.33.27.png)  ![Screenshot 2023-02-06 at 08.34.10.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_08.34.10.png)  | A | B | $C_{in}$ | $S$ | $C_{out}$ | | --- | --- | --- | --- | --- | | 0 | 0 | 0 | 0 | 0 | | 0 | 0 | 1 | 1 | 0 | | 0 | 1 | 0 | 1 | 0 | | 0 | 1 | 1 | 0 | 1 | | 1 | 0 | 0 | 1 | 0 | | 1 | 0 | 1 | 0 | 1 | | 1 | 1 | 0 | 0 | 1 | | 1 | 1 | 1 | 1 | 1 |  $$ \\begin{align*}S&amp;=A\\oplus B\\oplus C_{in}\\\\C_{out}&amp;=AB+BC_{in}+C_{in}A\\\\&amp;=AB+(A\\oplus B)C_{in}\\end{align*} $$  ![Screenshot 2023-02-07 at 20.40.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_20.40.11.png)  - **Carry propagate adder**     - An N-bit adder sums two N-bit inputs, A and B, and a carry in $C_{in}$ to produce an N-bit result $S$ and a carry out $C_{out}$.     - It is commonly called a carry propagate adder(CPA) because the carry out of one bit propagates into the next bit. The symbol for a CPA is shown in Figure 5.4; it is drawn just like a full adder except that A, B and $S$ are busses rather than single bits.     - Three common CPA implementations are called ripple-carry adders, carry-lookahead adders, and prefix adders.      ![Screenshot 2023-02-06 at 08.48.43.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_08.48.43.png)      ![Screenshot 2023-02-06 at 08.56.02.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_08.56.02.png)      ![Screenshot 2023-02-06 at 08.46.54.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_08.46.54.png)  - **Ripple-Carry Adder**     - The simplest way to build an **N-bit carry propagate adder** is to **chain together N full adders**.     - The $C_{out}$ of one stage acts as the $C_{in}$ of the next stage, as shown in Figure 5.5 for 32-bit addition. This is called a **ripple-carry adder**.     - It is a good application of modularity and regularity: the full adder module is reused many times to form a larger system.     - The ripple-carry adder has the advantage of being slow when $N$ is large. $S_{31}$ depends on $C_{30}$, which depends on $C_{29}$, which depends on $C_{28}$, and so forth all the way back to $C_{in}$, as shown in Figure 5.5. We say that the carry ripples through the carry chain.     - The delay of the adder, $t_{ripple}$, grows directly with the number of bits, as given in Equation 5.1, where $t_{FA}$ is the delay of a full adder.          $$         t_{ripple}=Nt_{FA}         $$       &gt; Schematics typically show signals flowing from left to right. Arithmetic circuits break this rule because the carries flow from right to left(from the least significant column to the most significant column).     &gt;       ![Screenshot 2023-02-06 at 08.58.37.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_08.58.37.png)      ![Screenshot 2023-02-06 at 09.36.16.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_09.36.16.png)      ![Screenshot 2023-02-06 at 09.36.40.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_09.36.40.png)  - **Carry-Lookahead Adder(!!!)**     - The fundamental reason that **large ripple-carry adders are slow** is that **the carry signals must propagate through every bit in the adder**.     - A **carry-lookahead adder(CLA)** is another type of carry propagate adder that solves this problem by **dividing the adder into blocks** and providing circuitry to **quickly determine the carry out of a block** as soon as the **carry in is known**. For example, a 32-bit adder may be divided into eight 4-bit blocks.     - CLAs use generate(G) and propagate(P) signals that describe how a column or block determines the carry out.     - The $i$th column of an adder is said to **generate a carry** if it **produces a carry out independent of the carry in**. The $i$th column of an adder is guaranteed to **generate a carry $C_i$ if $A_i$ and $B_i$ are both 1**. Hence $G_i$, the generate signal for column $i$, is calculated as $G_i=A_iB_i$.     - The column is said to **propagate a carry** if it **produces a carry out whenever there is a carry in**. The $i$th column will **propagate a carry in, $C_{i-1}$, if either $A_i$ or $B_i$ is 1**. Thus, $**P_i=A_i+B_i**$.     - Using these definitions, we can rewrite the carry logic for a particular column of the adder. The $i$th column of an adder will generate a carry out $C_i$ if it either generates a carry, $G_i$, or propagates a carry in, $P_iC_{i-1}$. In equation form($C_i$ is actually $C_{out}$, and $C_{i-1}$ is actually $C_{in}$)          $$         C_i=G_i+P_iC_{i-1}=A_iB_i+(A_i+B_i)C_{i-1}         $$       ![Screenshot 2023-02-06 at 14.38.21.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_14.38.21.png)      ![Screenshot 2023-02-06 at 15.00.15.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_15.00.15.png)      - \u8fd9\u91cc\u6211\u4eec\u9700\u8981\u6ce8\u610f\u4e00\u4e0b\u89d2\u6807\u7684\u95ee\u9898\uff0c\u4e24\u4e2a$N$-bit\u7684\u6570\u6765\u4f5c\u52a0\u6cd5\uff0c\u6211\u4eec\u4ece\u53f3\u5411\u5de6\u4ece0\u5f00\u59cb\u8fdb\u884c\u6807\u53f7\uff0c$G_i\\,$\u548c$\\,P_i\\,$\u7684\u89d2\u6807\u90fd\u4e0d\u5b58\u5728\u4efb\u4f55\u7684\u95ee\u9898\uff0c\u552f\u4e00\u9700\u8981\u6ce8\u610f\u7684\u5c31\u662f$\\,C_i\\,$\u7684\u89d2\u6807\u95ee\u9898\uff0c\u9996\u5148$\\,C_i\\,$\u7684\u5b9a\u4e49\u662f\u5341\u5206\u660e\u786e\u7684\uff0c\u5b83\u548c$\\,G_i$, $P_i\\,$\u4e00\u6837\uff0c\u90fd\u662f\u9488\u5bf9\u5f53\u524d\u8fd9\u4e00\u4f4d\u6765\u8ba8\u8bba\u7684\u3002\u56e0\u6b64$\\,C_i=G_i+P_iC_{i-1}\\,$\u8fd9\u4e2a\u516c\u5f0f\u672c\u8eab\u7684\u903b\u8f91\u662f\u6ca1\u6709\u95ee\u9898\u7684\uff0c\u5b83\u9610\u8ff0\u7684\u5c31\u662f\u5f53\u524d\u7b2c$\\,i\\,$\u5217\u7684\u8fdb\u4f4d$(C_i)$\u6765\u81ea\u4e24\u4e2a\u5730\u65b9\uff0c\u9996\u5148\u662f\u7b2c$\\,i\\,$\u5217 generate \u51fa\u7684 carry($\\,G_i\\,$)\uff0c\u5176\u6b21\u662f\u7b2c\u6765\u81ea$\\,i-1\\,$\u5217\u7684\u8fdb\u4f4d($\\,C_{i-1}\\,$)\u6070\u5de7\u53ef\u4ee5\u5728\u7b2c$\\,i\\,$\u5217\u5f97\u5230\u4f20\u5bfc($\\,P_i\\,$).     - \u4f46\u662f\u6211\u4eec\u901a\u8fc7\u4e0a\u65b9\u6700\u53f3\u4fa7\u7684\u56fe\u53ef\u4ee5\u770b\u51fa$\\,C_i\\,$\u5176\u5b9e\u662f\u6807\u6ce8\u5728\u4e86\u7b2c$\\,i+1\\,$\u5217\u4e0a\uff0c\u8fd9\u4e5f\u5c31\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u6700\u53f3\u4fa7\u7b2c\u96f6\u5217\u4e0a\u65b9\u7684\u8fdb\u4f4d\u662f$C_{-1}$\uff0c\u540c\u65f6$C_{-1}$\u7684\u503c\u5176\u5b9e\u662f\u53ef\u4ee5\u4eba\u4e3a\u8bbe\u5b9a\u7684\uff0c$C_{-1}\\,$\u53d61\u53ef\u4ee5\uff0c\u53d60\u4e5f\u53ef\u4ee5\uff0c\u770b\u4f60\u9700\u4e0d\u9700\u8981\u4e00\u4e2a\u521d\u59cb\u7684\u8fdb\u4f4d($C_{-1}$\u6807\u6ce8\u5728\u53f3\u4fa7\u7b2c0\u5217\u4e0a)\uff0c\u8fd9\u4e00\u70b9\u9700\u8981\u7279\u522b\u5173\u6ce8\u4e00\u4e0b\u3002     - The generate and propagate definitions extend to multiple-bit blocks.         - A block is said to generate a carry if it produces a carry out independent of the carry in to the block.         - The block is said to propagate a carry if it produces a carry out whenever there is a carry in to the block.         - We define $G_{i:j}$ and $P_{i:j}$ as generate and propagate signals for blocks spanning columns $i$ through $j$.     - A block generates a carry if the most significant column generates a carry, **or if the most significant column propagates a carry and the previous column generated a carry**, and so forth. For example, the generate logic for a block spanning column 3 through 0 is          $$         \\begin{align*}G_{3:0}&amp;=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0\\\\&amp;=G_3+P_3\\big(G_2+P_2(G_1+P_1G_0)\\big)\\end{align*}         $$      - A block propagates a carry if all the columns in the block propagates the carry. For example, the propagate logic for a block spanning columns 3 through 0 is          $$         P_{3:0}=P_3P_2P_1P_0         $$      - Using the block generate and propagate signals, we can quickly compute the carry out of the block, $C_i$, using the carry into the block, $C_{j-1}$.          $$         C_i=G_{i:j}+P_{i:j}C_{j-1}         $$       ![Screenshot 2023-02-06 at 14.41.51.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_14.41.51.png)      ![Screenshot 2023-02-06 at 14.43.28.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_14.43.28.png)      ![Screenshot 2023-02-06 at 16.41.49.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_16.41.49.png)      ![Screenshot 2023-02-06 at 16.41.34.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_16.41.34.png)      - \u8fd9\u91cc\u4e5f\u6709\u4e00\u4e9b\u7ec6\u8282\u503c\u5f97\u6ce8\u610f\uff0c\u9996\u5148\u4f8b\u5982\u5199\u6210$\\,P_{3:0}$, $G_{3:0}$\u5f62\u5f0f\uff0c\u5e76\u4e0d\u610f\u5473\u7740\u8fd9\u4e24\u4e2a\u4fe1\u53f7\u662f4-bit\u7684\uff0c\u76f8\u53cd\uff0c\u8fd9\u4e24\u4e2a\u4fe1\u53f7\u90fd\u662fsingle-bit signal\u3002$P_{3:0}$\u662fblock propagate signal\uff0c\u8fd9\u4e2a\u4fe1\u53f7\u7684\u542b\u4e49\u662f\u5982\u679c\u5bf9\u8fd9\u4e2ablock\u800c\u8a00\u6709\u4e00\u4e2acarry-in\uff0c\u8fd9\u4e2ablock\u662f\u5426\u80fd\u591f\u4f20\u9012\u51fa\u4e00\u4e2acarry-out\u3002\u5bf9\u4e8e\u5de61\u56fe\u4e2d\u7684\u5b9e\u9645\u4f8b\u5b50\uff0c\u6307\u7684\u5c31\u662f$\\,P_{3:0}\\,$\u5e76\u4e0d\u662f\u4e00\u4e2a4-bit signal\uff0c$P_{3:0}\\,$\u662f\u4e00\u4e2aone-bit signal\u3002\u5982\u679c$\\,P_{3:0}\\,$\u662f1\uff0c\u90a3\u4e48\u610f\u5473\u7740\u5bf9\u4e8e\u8fd9\u4e2ablock(\u4ece\u7b2c0\u5217\u5230\u7b2c3\u5217\uff0c\u603b\u51714\u5217\u7684block)\u6765\u8bf4\uff0c\u5982\u679c\u5b83\u6709carry-in(\u5728\u8fd9\u4e2a\u5177\u4f53\u7684\u4f8b\u5b50\u4e2d\u6307\u7684\u5c31\u662f$C_{-1}=1$),\u90a3\u4e48\u5b83\u6700\u7ec8\u4f1a\u4f20\u5bfc\u51fa\u4e00\u4e2acarry-out\uff0c\u5373($C_3=1$)\u3002\u5982\u679c$\\,P_{3:0}\\,$\u662f0\uff0c\u90a3\u4e48\u610f\u5473\u7740\u5bf9\u4e8e\u8fd9\u4e2ablock(\u4ece\u7b2c0\u5217\u5230\u7b2c3\u5217\uff0c\u603b\u51714\u5217\u7684block)\u6765\u8bf4\uff0c\u5982\u679c\u5b83\u6709carry-in(\u5728\u8fd9\u4e2a\u5177\u4f53\u7684\u4f8b\u5b50\u4e2d\u6307\u7684\u5c31\u662f$C_{-1}=1$),\u90a3\u4e48\u5b83\u6700\u7ec8\u65e0\u6cd5\u4f20\u5bfc\u51fa\u4e00\u4e2acarry-out\uff0c\u5373($C_3=0$)\u3002     - $G_{3:0}\\,$\u867d\u7136\u5728\u5f62\u5f0f\u4e0a\u50cf\u662f\u4e00\u4e2a4-bit\u7684signal\uff0c\u4f46\u5176\u5b9e\u5b83\u4e5f\u662fsingle-bit signal\uff0c\u6211\u4eec\u628a$\\,G_{3:0}\\,$\u79f0\u4f5cblock. generate signal\uff0c\u8fd9\u4e2a\u4fe1\u53f7\u7684\u542b\u4e49\u662f\u82e5$G_{3:0}=1$\uff0c\u5219\u4e0d\u7ba1\u5916\u754c\u5230\u5e95\u6709\u6ca1\u6709carry-in\uff0c\u7531\u8fd9\u4e2ablock\u672c\u8eab\u5c31\u53ef\u4ee5generate\u51fa\u8fdb\u4f4d(carry)\uff0c\u5728\u4e0a\u9762\u5de62\u56fe\u4e2d\u7684\u4f8b\u5b50\u91cc\u5177\u4f53\u6307\u65e0\u8bba$\\,C_{-1}=0$ \u8fd8\u662f$\\,C_{-1}=1$\uff0c$C_3=1$\u3002\u82e5$G_{3:0}=1$\uff0c\u5219\u4ec5\u7531\u8fd9\u4e2ablock\u672c\u8eab\u662f\u65e0\u6cd5\u81ea\u5df1generate\u51fa\u8fdb\u4f4d\u7684(\u6ce8\u610f\u8fd9\u91cc\u7684\u8fdb\u4f4d\u662f\u6307\u5bf9\u4e8e\u6574\u4e2ablock\u800c\u8a00\uff0c\u5982\u679c\u5185\u90e8\u6709\u8fdb\u4f4d\u4f46\u662f\u6574\u4e2ablock\u6700\u540e\u4e0d\u80fd\u5411\u4e0b\u4e00\u4e2ablock\u4f20\u9012\u4e00\u4e2a\u8fdb\u4f4d\u7684\u8bdd\u4e5f\u662f\u6ca1\u6709\u7528\u7684)\u3002\u63a5\u4e0b\u6765\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u4efb\u52a1\u5c31\u662f\u6765\u601d\u8003$\\,G_{3:0}\\,$\u4f55\u65f6\u4e3a1\uff1f\u901a\u8fc7\u601d\u8003\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u5f53$\\,G_3=1\\,$\u6216$\\,G_2=1,P_3=1\\,$\u6216$\\,G_1=1,P_2=P_3=1\\,$\u6216$\\,G_0=1,P_1=P_2=P_3=1$\u5171\u8ba1\u56db\u79cd\u60c5\u51b5\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u628a$\\,G_{3:0}\\,$\u5199\u6210\u5982\u4e0b\u7684\u5f62\u5f0f\uff1a          $$         \\begin{align*}G_{3:0}&amp;=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0\\\\&amp;=G_3+P_3\\big(G_2+P_2(G_1+P_1G_0)\\big)\\end{align*}         $$       - Figure 5.6(a) shows a 32-bit carry-lookahead adder composed of eight 4-bit blocks. Each block contains a 4-bit ripple-carry adder and some lookahead logic to compute the carry out of the block given the carry in, as shown in Figure 5.6(b)      $$     \\begin{align*}G_{3:0}&amp;=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0\\\\&amp;=G_3+P_3\\big(G_2+P_2(G_1+P_1G_0)\\big)\\\\\\\\P_{3:0}&amp;=P_3P_2P_1P_0\\\\\\\\C_i&amp;=G_{i:j}+P_{i:j}C_{j-1}\\\\\\\\C_3(C_{out})&amp;=G_{3:0}+P_{3:0}C_{-1}(C_{in})\\\\&amp;=G_3+P_3\\big(G_2+P_2(G_1+P_1G_0)\\big)+P_3P_2P_1P_0C_{-1}(C_{in})\\end{align*}     $$      ![Screenshot 2023-02-06 at 13.48.52.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_13.48.52.png)      - \u53f3\u56fe\u6240\u793a\u768432-bit CLA(carry-lookahead adder)\u662f\u75318\u4e2a4-bit blocks\u7ec4\u6210\u7684\u3002\u5176\u4e2d\u6bcf\u4e00\u4e2a4-bit block\u7684\u5185\u90e8\u7ed3\u6784\u90fd\u5728\u53f3\u56fe\u4e2d\u4e88\u4ee5\u653e\u5927\u5448\u73b0\u3002     - \u5f53\u628a4-bit block\u653e\u5927\u6765\u770b\uff0c\u5176\u5b9e\u548c4\u4e2aripple-carry adder\u4e32\u8054\u5728\u4e00\u8d77\u51e0\u4e4e\u6ca1\u6709\u533a\u522b\uff0c**\u552f\u4e00\u7684\u533a\u522b\u5c31\u662f\u6211\u4eec\u627e\u4e0d\u5230\u8fd9\u4e2aripple-carry adder\u7684$\\,C_{out}\\,$**. \u800c\u4e8b\u5b9e\u4e0a$**\\,C_{out}\\,$\u4f5c\u4e3a\u6574\u4e2ablock\u7684\u8f93\u51fa\u662f\u901a\u8fc7\u4e0b\u9762\u4e00\u4e2a\u770b\u8d77\u6765\u8f83\u4e3a\u590d\u6742\u7684\u7535\u8def\u6765\u8ba1\u7b97\u5f97\u5230\u7684**\u3002\u4e5f\u5c31\u662f\u8bf4\u8fd9\u4e2a4-bit block\u7684carry-out\u662f\u901a\u8fc7\u4e0b\u65b9\u7684\u7535\u8def\u6765\u8ba1\u7b97\u5f97\u5230\u7684\u3002     - \u6211\u4eec\u628a$\\,S_0,S_1,S_2,S_3\\,$\u7b49\u79f0\u4e3asum bits\uff0c\u53ef\u4ee5\u5f97\u77e5**sum bits\u4f9d\u7136\u662f\u901a\u8fc7ripple-carry adder\u8ba1\u7b97\u51fa\u6765\u7684\uff0c\u5e76\u4e0d\u8d70\u4e0b\u65b9\u7684\u590d\u6742\u7535\u8def**\uff0c\u5373\u5229\u7528$\\,A_0,B_0,C_{in}\\,$\u8ba1\u7b97\u5f97\u5230$\\,S_0\\,$\uff0c\u540c\u65f6\u8fdb\u4f4d\u5f97\u5230$\\,C_0\\,$\uff0c\u5229\u7528$A_1,B_1,C_0\\,$\u8ba1\u7b97\u5f97\u5230$\\,S_1\\,$\uff0c\u540c\u65f6\u8fdb\u4f4d\u5f97\u5230$\\,C_1\\,$\uff0c\u5229\u7528$\\,A_2,B_2,C_1\\,$\u8ba1\u7b97\u5f97\u5230$\\,S_2\\,$\uff0c\u540c\u65f6\u8fdb\u4f4d\u5f97\u5230$\\,C_2\\,$\uff0c\u5229\u7528$A_3,B_3,C_2\\,$\u8ba1\u7b97\u5f97\u5230$\\,S_3\\,$\uff0c**\u4f46\u662f$\\,C_3\\,$\u4e0d\u9700\u8981\u8fd9\u6837\u4e00\u6b65\u4e00\u6b65\u5012\u817e\u51fa\u6765\uff0c\u6211\u4eec\u5229\u7528block\u7684\u601d\u60f3\uff0c\u53ef\u4ee5\u66f4\u5feb\u7684\u8ba1\u7b97\u51fa$\\,C_3\\,$**\u3002          $$         \\begin{align*}C_3(C_{out})&amp;=G_{3:0}+P_{3:0}C_{-1}(C_{in})\\\\&amp;=G_3+P_3\\big(G_2+P_2(G_1+P_1G_0)\\big)+P_3P_2P_1P_0C_{-1}(C_{in})\\end{align*}         $$      - \u6211\u4eec\u53ef\u4ee5\u628a$\\,G_i\\,$\u79f0\u4f5c\u662fcolumn generate signal\uff0c\u628a$\\,P_i\\,$\u79f0\u4f5c\u662fcolumn propagate signal\u3002\u628a$\\,G_{i:j}\\,$\u79f0\u4f5c\u662fblock generate signal\uff0c\u628a$\\,P_{i:j}\\,$\u79f0\u4f5c\u662fblock propagate signal\u3002\u5728\u53f3\u4fa7\u7684\u56fe\u793a\u4e2d\uff0c\u5982$\\,G_{3:0}$\uff0c$P_{3:0}\\,$\u901a\u8fc7\u56fe\u793a\u7684\u7535\u8def\u6765\u8ba1\u7b97\uff0c\u800c\u6211\u4eec\u5728\u56fe\u4e2d\u6ca1\u6709\u5448\u73b0\u51fa$\\,G_i\\,$\u548c$\\,P_i\\,$\u7684\u7535\u8def\uff0c\u524d\u8005\u7528AND gate\u5373\u53ef\u5b9e\u73b0\uff0c\u540e\u8005\u7528OR gate\u5373\u53ef\u5b9e\u73b0\u3002      ![Screenshot 2023-02-06 at 16.43.51.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_16.43.51.png)      - \u770b\u8d77\u6765\u4e0a\u65b9\u56fe\u793a\u4e2d\u6700\u5e95\u4e0b\u7684\u7535\u8def\u56fe\u4e5f\u5f88\u6050\u6016\uff0c\u90a3\u4e48\u5b83\u76f8\u6bd4\u4e8e\u628afull adder\u4e32\u8054\u8d77\u6765\u5f62\u6210\u7684ripple-carry adder\u5230\u5e95\u901f\u5ea6\u6709\u6ca1\u6709\u660e\u663e\u7684\u63d0\u5347\u5462\uff1f\u6211\u4eec\u5c31\u6765\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a\u95ee\u9898\uff01     - \u9996\u5148\u503c\u5f97\u660e\u786e\u7684\u662f$\\,A_0,A_1\\cdots,A_{31}\\,$\u4ee5\u53ca$B_0,B_1,\\cdots,B_{31}$\u5728\u521d\u59cb\u6761\u4ef6\u4e0b\u5c31\u662f\u5df2\u77e5\u91cf\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u505a\u7684\u5c31\u662f\u4e24\u4e2a32-bit\u7684\u6570\u76f8\u52a0\u7684\u5de5\u4f5c\uff0c\u8fd9\u4e24\u4e2a\u6570\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u77e5\u9053\u7684\uff0c\u4e0d\u9700\u8981\u8fdb\u884c\u4efb\u4f55\u7684\u8fd0\u7b97\u3002\u5728\u7ecf\u8fc71\u4e2agate\u7684delay\u540e(AND gate\u6216\u8005OR gate)\uff0c\u6240\u6709\u7684$\\,G_i$\uff0c$P_i$\u90fd\u662f\u5df2\u77e5\u7684\uff0c\u6ce8\u610f\u8fd9\u91cc\u6240\u6709\u7684$\\,G_i$\uff0c$P_i$\u540c\u65f6\u5df2\u77e5\u3002\u56e0\u4e3a\u5728\u6bcf\u4e2afull adder\u5185\u90e8$\\,G_i=A_iB_i\\,$\uff0c$P_i=A_i+B_i$\u3002     - \u5bf9\u4e8e\u4e0a\u56fe\u6240\u793a\u7684\u5177\u4f53\u60c5\u51b5\u800c\u8a00\uff0c\u521a\u624d\u63d0\u5230\u5728\u7ecf\u8fc71\u4e2agate\u7684delay\u540e(AND gate\u6216\u8005OR gate)\uff0c\u6240\u6709\u7684$\\,G_i$\uff0c$P_i$\u90fd\u662f\u5df2\u77e5\u7684\u3002\u518d\u7ecf\u8fc76\u4e2agate\u7684delay\u540e\uff0c\u6240\u6709\u7684block generate signal\u90fd\u662f\u5df2\u77e5\u7684\uff0c\u5982$\\,G_{3:0},G_{7:4},G_{11:8},\\cdots$\u3002\u5f53\u7136\u57286\u4e2agate\u7684delay\u4e4b\u5185\uff0c\u4e0b\u65b9\u6240\u6709\u7684block propagate signal\u4e5f\u540c\u65f6\u5168\u90e8\u5df2\u77e5\uff0c\u5982$\\,P_{3:0},P_{7:4},P_{11:8},\\cdots$\u3002     - \u5728\u5f97\u5230\u6240\u6709\u7684block generate signal\u548cblock propagate signal\u4e4b\u540e(\u524d\u8005\u6839\u636e\u56fe\u793a\u6bd4\u540e\u8005\u82b1\u8d39\u7684\u65f6\u95f4\u8981\u66f4\u957f)\uff0c\u6211\u4eec\u518d\u9700\u89812\u4e2agate\u7684delay\u4fbf\u53ef\u4ee5\u7531$\\,C_{in},G_{3:0},P_{3:0}\\,$\u5f97\u5230$\\,C_{out}\\,$(block carry-out\uff0c\u5373$\\,C_3\\,$)\u3002     - \u5728\u5f97\u5230\u4e86$\\,C_3\\,$\u4e4b\u540e\uff0c\u63a5\u4e0b\u6765\u6240\u6709\u7684block carry-out\u90fd\u53ef\u4ee5\u4eff\u7167\u7c7b\u4f3c\u7684\u65b9\u6cd5\u77ac\u95f4\u5f97\u5230\uff0c\u56e0\u4e3a\u6bcf\u4e00\u4e2ablock\u4e2d\uff0cblock generate signal \u548c block propagate signal \u5df2\u7ecf\u51c6\u5907\u597d\u4e86\uff0c\u6bcf\u4e00\u4e2ablock\u90fd\u5728\u7b49\u5f85\u4e00\u4e2a$\\,C_{in}\\,$\uff0c\u8fd9\u4e2a$\\,C_{in}\\,$\u4e0d\u662f\u522b\u7684\uff0c\u6b63\u662f\u524d\u4e00\u4e2ablock\u7684block carry-out\uff0c\u8fd9\u6837\u5982\u540c\u8fde\u9501\u53cd\u5e94\u4e00\u6837\uff0c\u6211\u4eec\u5728\u5f97\u5230$\\,C_3\\,$\u540e\u53ef\u4ee5\u5feb\u901f\u5f97\u5230$\\,C_7,C_{11},C_{15},C_{19},C_{23},C_{27},C_{31\\,}$\u3002      ![Screenshot 2023-02-06 at 17.50.27.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_17.50.27.png)      ![Screenshot 2023-02-06 at 17.50.30.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_17.50.30.png)      ![Screenshot 2023-02-06 at 17.50.31.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_17.50.31.png)      ![Screenshot 2023-02-06 at 17.50.33.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_17.50.33.png)      - \u4e0a\u9762\u4e00\u7ec4\u56fe\u7684\u56fe3\u6307\u7684\u5c31\u662f\u5f97\u5230$\\,C_3\\,$\u540e\u53ef\u4ee5\u5feb\u901f\u5f97\u5230$\\,C_7,C_{11},C_{15},C_{19},C_{23},C_{27},C_{31\\,}$\u7684\u8fc7\u7a0b\u3002     - \u4e0a\u9762\u4e00\u7ec4\u56fe\u7684\u56fe4\u8bf4\u660e\u7684\u5c31\u662f\uff0c\u6700\u540e\u4e00\u4e2ablock\u63a5\u6536\u5230$\\,C_{27}\\,$\u4f5c\u4e3a$\\,C_{in}\\,$\uff0c\u8fd8\u5fc5\u987b\u8981\u8d704\u4e2afull adder\u7ec4\u6210\u76844-bit block\uff0c\u8fd9\u6837\u624d\u53ef\u4ee5\u628a\u6700\u9ad8\u7684\u56db\u4f4d\u7684\u7ed3\u679c\u7b97\u51fa\u6765\u3002     - The AND and OR gates needed to compute the single-bit generate and propagate signals, $G_i$ and $P_i$, from $A_i$ and $B_i$ are left out for brevity($G_i=A_iB_i$, $P_i=A_i+B_i$, \u7528$\\,A_i\\,$\u548c$\\,B_i\\,$\u518d\u52a0\u4e0aAND gate\u5c31\u53ef\u4ee5\u6784\u9020\u51fa$\\,G_i$, \u7528$\\,A_i\\,$\u548c$\\,B_i\\,$\u518d\u52a0\u4e0aOR gate\u5c31\u53ef\u4ee5\u6784\u9020\u51fa$\\,P_i\\,$). Again, the carry-lookahead adder demonstrates modularity and regularity.     - All of the CLA blocks computer the single-bit and block generate and propagate signals simultaneously. The critical path starts with computing $G_0$ and $G_{3:0}$ in the first CLA block. $C_{in}$ then advances directly to $C_{out}$ through the AND/OR gate in each block until the last. For a large adder, this is much faster than waiting for the carries to ripple through each consecutive bit of the adder. Finally, the critical path through the last block contains a short ripple-carry adder. Thus, an $N$-bit adder divided into $k$-bit blocks has a delay           $$         t_{CLA}=t_{pg}+t_{pg\\_block}+\\bigg(\\dfrac{N}{k}-1\\bigg)t_{AND\\_OR}+kt_{FA}         $$          \u8fd9\u91cc\u9762\u63d0\u5230\u7684-1\uff0c\u6307\u7684\u5c31\u662f\u6700\u540e\u4e00\u6b21\u4e0d\u7528\u7a7f\uff0c\u5f97\u5230$\\,C_{27}\\,$\u4ee5\u540e\u5c31\u53ef\u4ee5\u4e86\uff0c\u7d27\u63a5\u7740\u8ddf\u7740\u7684\u662f$\\,kt_{FA}\\,$\u3002          **\u5728\u4e0a\u9762\u548c\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d$\\,t_{pg\\_block}\\,$\u4e2d\u7ecf\u8fc7\u7684gate\u6570\u91cf\u53ef\u4ee5\u7528\u4e0b\u9762\u7684\u516c\u5f0f\u8ba1\u7b97**          $**G_{i:j}\\,$\u5bf9\u5e94$\\,2\\times(i-j)\\,$\u4e2a\u95e8\uff0c\u8fd9\u4e5f\u6b63\u662f\u4e0b\u9762$\\,t_{pg\\_block}=6\\times100\\mathrm{ps}=600\\mathrm{ps}\\,$\u4e2d 6 \u7684\u6765\u5386\u3002**          ![Screenshot 2023-02-06 at 18.14.15.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_18.14.15.png)          ![Screenshot 2023-02-06 at 18.06.45.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_18.06.45.png)          where $t_{pg}$ is the delay of the individual generate/propagate gates(a single AND or OR gate) to generate $P_i$ and $G_i$, $t_{pg\\_block}$ is the delay to find the generate/propagate signals $P_{i:j}$ and $G_{i:j}$ for a $k$-bit block, and $t_{AND\\_OR}$ is the delay from $C_{in}$ to $C_{out}$ through the final AND/OR logic of the $k$-bit CLA block.      - For $N&gt;16$, the carry-lookahead adder is generally much faster than the ripple-carry adder. However, the adder delay still increases linearly with $N$. - **Prefix Adder**     - Prefix adders **extend the generate and propagate logic** of the **carry lookahead adder** to **perform addition even faster**.     - They first compute G and P for pairs of columns, then for blocks of 4, then for blocks of 8, then 16, and so forth until the generate signal for every column is known. The sums are computed from these generate signals.(**\u6211\u4e2a\u4eba\u8ba4\u4e3a\u8fd9\u4e2a\u8bf4\u6cd5\u4e0d\u591f\u51c6\u786e\uff0c\u5e94\u8be5\u8bf4\u662fgenerate signal for every block\uff0c\u4f8b\u5982$G_{i-1:-1}$**)     - In other words, the strategy of a prefix adder is to **compute the carry in $C_{i-1}$**(\u6ce8\u610f\u8fd9\u91cc\u8bf4\u7684\u662fcarry-in\uff0c\u4e0b\u6807\u662f$\\,i-1$) **for each column $i$** as quickly as possible, then to compute the sum, using          $$         S_i=(A_i\\oplus B_i)\\oplus C_{in}=(A_i\\oplus B_i)\\oplus C_{i-1}         $$      - Define column $i=-1$ to hold $C_{in}$, so $G_{-1}=C_{in}$ and $P_{-1}=0$\u3002\u7a0d\u5fae\u89e3\u91ca\u4e00\u4e0b\u8fd9\u4e2a\u662f\u4ec0\u4e48\u610f\u601d\uff0c\u9996\u5148$\\,C_{in}\\,$\u8bf4\u767d\u4e86\u5c31\u662f$\\,C_{-1}\\,$\u3002$C_{-1}\\,$\u5728\u6807\u6ce8\u7684\u65f6\u5019\u4f1a\u6807\u6ce8\u5230\u53f3\u4fa7\u7b2c0\u5217\u4e0a\u3002$C_{in}=C_{-1}=1\\,$\u65f6\uff0c\u6574\u4e2a\u7cfb\u7edf\u662f\u6709carry-in\uff0c\u8fd9\u4e2acarry-in\u53ef\u4ee5\u770b\u6210\u662f\u7531\u5217 -1 generate\u51fa\u6765\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u6b64\u65f6\u53ef\u4ee5\u8ba4\u4e3a$\\,G_{-1}=1\\,$\u3002$C_{in}=C_{-1}=0\\,$\u65f6\uff0c\u6574\u4e2a\u7cfb\u7edf\u6ca1\u6709carry-in\uff0c\u6b64\u65f6\u53ef\u4ee5\u770b\u6210\u662f\u5217 -1 \u6ca1\u6709generate\u51fa\u6765carry-in\uff0c\u6240\u4ee5\u6211\u4eec\u6b64\u65f6\u53ef\u4ee5\u8ba4\u4e3a$\\,G_{-1}=0\\,$\u3002\u7efc\u4e0a\u6240\u8ff0\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba9$\\,C_{-1}=C_{in}$\uff0c\u540c\u65f6$\\,G_{-1}=C_{in}=C_{-1},P_{-1}=0$\u3002      ![Screenshot 2023-02-06 at 18.46.09.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_18.46.09.png)      ![Screenshot 2023-02-06 at 14.59.22.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_14.59.22.png)      - Then $C_{i-1}=G_{i-1:-1}$ because there will be a carry out of column $i-1$ if the block spanning columns $i-1$ through **-1** generates a carry. The generated carry is either generated in column $i-1$ or generated in a previous column and propagated.($**C_{i-1}=G_{i-1:-1}$\u662f\u4e00\u4e2a\u53cc\u5411\u7684\u8f6c\u6362\u5173\u7cfb\uff0c\u9700\u8981\u5b66\u4f1a\u719f\u7ec3\u4f7f\u7528\uff0c\u540c\u65f6\u9700\u8981\u6ce8\u610f\u7684\u662f$C_{i-1}$\u662f\u7b2c$i-1$\u5217\u7684carry-out\uff0c\u540c\u65f6\u4e5f\u662f\u7b2c$\\,i\\,$\u5217\u7684carry-in**)          \u8fd9\u91cc\u662f\u4e00\u4e2a\u91cd\u70b9\uff0c\u56e0\u6b64\u8be6\u7ec6\u5730\u89e3\u91ca\u4e00\u4e0b\u3002\u8fd9\u91cc\u7684\u91cd\u70b9\u5728\u4e8e\u5f15\u5165\u7684$\\,G_{-1}=C_{in}\\,$\u3002\u6211\u4eec\u53ef\u4ee5\u5bf9\u6bd4\u4e00\u4e0b\u4e0a\u9762\u7684\u4e24\u5f20\u56fe\uff0c\u5176\u4e2d\u63d0\u5230\u4e86\u5982\u4e0b\u7684\u4e24\u4e2a\u7b49\u5f0f\uff1a          $$         C_{i-1}=G_{i-1:-1}         $$          $$         C_3=G_{3:0}+P_{3:0}C_{-1}         $$          \u4e3a\u4ec0\u4e48\u8fd9\u4e24\u4e2a\u7b49\u5f0f\u770b\u8d77\u6765\u4e0d\u592a\u4e00\u6837\u5462\uff0c\u5176\u5b9e\u5c31\u662f$\\,G_{-1}=C_{-1}=C_{in}\\,$\u7684\u4e00\u4e2a\u7ec6\u8282\u3002\u6211\u4eec\u9996\u5148\u53ef\u4ee5\u8fd9\u6837\u7406\u89e3\uff1a          $$         \\begin{align*}G_{3:-1}&amp;=G_3+G_2P_3+G_1P_2P_3+G_0P_1P_2P_3+G_{-1}P_0P_1P_2P_3\\\\C_3&amp;=G_{3:0}+P_{3:0}C_{-1}\\\\&amp;=G_{3:0}+P_3P_2P_1P_0C_{-1}\\\\&amp;=(G_3+G_2P_3+G_1P_2P_3+G_0P_1P_2P_3)+P_3P_2P_1P_0G_{-1}\\\\&amp;=G_{3:-1}\\end{align*}         $$          \u9664\u6b64\u4e4b\u5916\uff0c\u7531\u4e8e\u6211\u4eec\u8003\u8651\u4e86\u4ece column $i-1$ \u5230 column **-1** \u7684\u8fd9\u4e2ablock\u662f\u5426\u4f1a generate \u51fa carry\uff0c\u6211\u4eec\u4e5f\u5c31\u4e0d\u518d\u9700\u8981\u8003\u8651\u4f20\u5bfc\u8fdb\u4f4d\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u8ffd\u6eaf\u5230\u4e86\u5217-1\uff0c\u6e90\u5934\u5904\u5df2\u7ecf\u4e0d\u53ef\u80fd\u6709\u4ec0\u4e48\u53ef\u4f9b\u4f20\u5bfc\u7684\u521d\u59cb\u8fdb\u4f4d.      - Thus, we rewrite equation          $$         S_i=(A_i\\oplus B_i)\\oplus C_{in}=(A_i\\oplus B_i)\\oplus C_{i-1}         $$          as          $$         S_i=(A_i\\oplus B_i)\\oplus G_{i-1:-1}         $$      - Hence, the main challenge is to rapidly compute all the block generate signals $G_{-1:-1},G_{0:-1},G_{1:-1},G_{2:-1},\\cdots,G_{N-2:-1}$. These signals, along with $P_{-1:-1},P_{0:-1},P_{1:-1},P_{2:-1},\\cdots P_{N-2:-1}$, are called prefixes.      - \u56e0\u4e3a\u6211\u4eec\u4e0a\u9762\u63d0\u5230\u4e86\u63a5\u4e0b\u6765\u4e3b\u8981\u7684\u96be\u70b9\u5c31\u662f\u5feb\u901f\u8ba1\u7b97\u51fa$G_{-1:-1},G_{0:-1},G_{1:-1},G_{2:-1},\\cdots,G_{N-2:-1}$\u548c $P_{-1:-1},P_{0:-1},P_{1:-1},P_{2:-1},\\cdots P_{N-2:-1}$\uff0c\u90a3\u4e48\u8fd9\u4e9b\u4e1c\u897f\u8be5\u5982\u4f55\u8ba1\u7b97\uff0c\u53f3\u8fb9\u7684\u8fd9\u5f20\u56fe\u7247\u4e2d\u7684\u4e24\u4e2a\u516c\u5f0f\u5c31\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u8ba1\u7b97\u7684\u601d\u8def\u3002     - \u8003\u8651\u8ba1\u7b97\u4e00\u822c\u7684\u60c5\u51b5 generate and propagate signals for a block spanning bits $i:j$\u3002\u6ce8\u610f\u5728\u8fd9\u4e2a\u5730\u65b9\u6709$\\,i&gt;j\\,$\u3002          $$         \\begin{align*}G_{i:j}&amp;=G_{i:k}+P_{i:k}G_{k-1:j}\\\\P_{i:j}&amp;=P_{i:k}P_{k-1:j}\\end{align*}         $$          \u5bf9\u4e8e\u8fd9\u4e24\u4e2a\u516c\u5f0f\u7684\u6587\u5b57\u89e3\u8bfb\uff0c\u53f3\u4fa7\u7684\u56fe\u7247\u4e2d\u5df2\u7ecf\u89e3\u91ca\u5f97\u5f88\u660e\u767d\u4e86\uff0c\u5982\u679c\u4e0d\u559c\u6b22upper part\u548clower part\u7684\u8868\u8ff0\uff0c\u5176\u5b9e\u4e5f\u53ef\u4ee5\u628a\u4e0b\u6807\u4e3a$\\,i:k\\,$\u7684\u90e8\u5206\u7406\u89e3\u4e3aleft part\uff0c\u540c\u65f6\u628a\u4e0b\u6807\u4e3a$\\,k-1:j\\,$\u7684\u90e8\u5206\u7406\u89e3\u4e3aright part\u3002      - \u63a5\u4e0b\u6765\u6211\u4eec\u6765\u8003\u8651\u8fd9\u6837\u4e00\u4e2a\u4f8b\u5b50          $$         1010+0111=\\,?\\,\\,\\,C_{in}=1         $$          |  | 1 | 0 | 1 | 0 |  |         | --- | --- | --- | --- | --- | --- |         |  | 0 | 1 | 1 | 1 |  |         | carry $C_{i-1}$ | 1($C_2$) | 1($C_1$) | 1($C_0$) | 1($C_{-1}$) |  |         | column number i | 3 | 2 | 1 | 0 | -1 |         | $G_i$ | 0 | 0 | 1 | 0 | 1 |         | $P_i$ | 1 | 1 | 1 | 1 |  |         1. \u9996\u5148\u7b2c\u4e00\u6b65\u8fd8\u662f\u8ba1\u7b97\u51fa1-bit\u7684\u60c5\u5f62\uff0c\u5373\u5355\u72ec\u7684$\\,G_i\\,$\u548c $P_i$\uff0c\u9075\u5faa\u7684\u539f\u5219\u4f9d\u7136\u662f              $$             \\begin{align*}G_i&amp;=A_iB_i\\\\P_i&amp;=A_i+B_i\\end{align*}             $$          2. \u5728\u8ba1\u7b97\u51fa1-bit\u7684\u60c5\u5f62\u4e4b\u540e\uff0c\u6211\u4eec\u6309\u7167\u539f\u5b9a\u8ba1\u5212\u5c31\u60f3\u8981\u6765\u8ba1\u7b97\u51fa2-bit\u7684\u60c5\u51b5              $$             \\begin{align*}G_{0:-1}&amp;=G_{0:0}+P_{0:0}G_{-1:-1}=0+1=1=C_0\\\\G_{2:1}&amp;=G_{2:2}+P_{2:2}G_{1:1}=0+1=1\\\\P_{2:1}&amp;=P_{2:2}P_{1:1}=1\\end{align*}             $$          3. \u5728\u8ba1\u7b97\u51fa2-bit\u7684\u60c5\u51b5\u540e\uff0c\u6211\u4eec\u6309\u7167\u539f\u5b9a\u8ba1\u5212\u5c31\u60f3\u8981\u6765\u8ba1\u7b97\u51fa4-bit\u7684\u60c5\u51b5\uff0c\u5f53\u7136\u4e0e\u6b64\u540c\u65f6\u6211\u4eec\u4e5f\u53ef\u4ee5\u8ba1\u7b97\u51fa\u4e00\u4e9b\u975e2\u7684\u5e42bit\u7684\u60c5\u51b5\uff0c\u6765\u770b\u8be6\u7ec6\u8fc7\u7a0b              $$             \\begin{align*}G_{2:-1}&amp;=G_{2:1}+P_{2:1}G_{0:-1}=1+1=1=C_2\\\\G_{1:-1}&amp;=G_{1:1}+P_{1:1}G_{0:-1}=1+1=1=C_1\\end{align*}             $$          4. \u5230\u8fd9\u91cc\uff0c\u6211\u4eec\u5c31\u8ba1\u7b97\u51fa\u4e86\u5982\u4e0b\u7ed3\u679c              $$             \\begin{align*}C_2=C_1=C_0=C_{-1}=1\\end{align*}             $$              $$             G_{2:-1}=G_{1:-1}=G_{0:-1}=G_{-1:-1}=1             $$          5. \u6700\u540e\u6211\u4eec\u8981\u505a\u7684\u5c31\u662f\u5957\u7528\u516c\u5f0f              $$             S_i=A_i\\oplus B_i\\oplus C_{i-1}             $$              \u6765\u8ba1\u7b97sum bits.              $$             \\begin{align*}S_0&amp;=A_0\\oplus B_0\\oplus C_{-1}=0\\oplus1\\oplus1=0\\\\S_1&amp;=A_1\\oplus B_1\\oplus C_0=1\\oplus1\\oplus1=1\\\\S_2&amp;=A_2\\oplus B_2\\oplus C_1=0\\oplus1\\oplus1=0\\\\S_3&amp;=A_3\\oplus B_3\\oplus C_2=1\\oplus0\\oplus1=0\\end{align*}             $$       ![Screenshot 2023-02-06 at 20.28.16.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_20.28.16.png)      ![Screenshot 2023-02-06 at 23.20.58.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_23.20.58.png)      \u6ce8\u610f\u4e0a\u9762\u7684\u8fd9\u5f20\u56fe\u7247\u4e2d$\\,S_i\\,$\u7684\u8ba1\u7b97\u516c\u5f0f\u6709\u95ee\u9898\uff0c$S_i\\,$\u7684\u6b63\u786e\u516c\u5f0f\u662f      $$     S_i=A_i\\oplus B_i\\oplus C_{i-1}     $$      ![Screenshot 2023-02-06 at 22.39.33.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_22.39.33.png)      - Figure 5.7 shows an $N$= 16-bit prefix adder. The adder begins with a precomputation to form $P_i$ and $G_i$ for each column from $A_i$ and $B_i$ using AND and OR gates.     - It then uses $\\log_2N=4$ levels of black cells to form the prefixes of $G_{i:j}$ and $P_{i:j}$. A black cell takes inputs from the upper part of a block spanning bits $i:k$ and from the lower part spanning bits $k-1:j$. It then combines these parts to form generate and propagate signals for the entire block spanning bits $i:j$ using the equations          $$         \\begin{align*}G_{i:j}&amp;=G_{i:k}+P_{i:k}G_{k-1:j}\\\\P_{i:J}&amp;=P_{i:k}P_{k-1:j}\\end{align*}         $$      - In other word, a block spanning bits $i:j$ will generate a carry if the upper part generates a carry or if the upper part propagates a carry generated in the lower part. The block will propagate a carry if both the upper part and lower parts propagate the carry.     - Finally, the prefix adder computers the sums using          $$         S_i=(A_i\\oplus B_i)\\oplus G_{i-1:-1}         $$       ![Screenshot 2023-02-06 at 23.33.28.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-06_at_23.33.28.png)      - \u63a5\u4e0b\u6765\u8ba9\u6211\u4eec\u5bf9\u4e8eprefix adder schematic\u8fdb\u884c\u8be6\u7ec6\u89e3\u8bfb\u3002\u8fd9\u5f20\u56fe\u63cf\u8ff0\u7684\u662f\u4e00\u4e2a16-bit prefix adder\uff0c\u6574\u5f20\u56fe\u5206\u4e3a\u4e09\u5927\u90e8\u5206\uff0c\u4e0a\u9762\u7684\u9ec4\u8272\u90e8\u5206\u3001\u4e2d\u95f4\u7684\u9ed1\u8272\u90e8\u5206\u548c\u4e0b\u9762\u7684\u84dd\u8272\u90e8\u5206\u3002     - \u6bcf\u4e00\u4e2a\u9ec4\u8272\u90e8\u5206\u90fd\u662f\u7528\u6765\u5b9e\u73b0column generate and propagate signal\uff0c\u5373$\\,G_i\\,$\u548c$\\,P_i\\,$\uff0c\u5176\u4e2d$\\,G_i=A_iB_i\\,$\uff0c$P_i=A_i+B_i$\uff0c\u5728\u56fe\u4e2d\u4e3a\u4e86\u683c\u5f0f\u7edf\u4e00\u6211\u4eec\u628a$\\,G_i\\,$\u548c$\\,P_i\\,$\u6269\u5c55\u6210\u4e86$\\,G_{i:i}\\,$\u4ee5\u53ca$\\,P_{i:i}\\,$\u7684\u5f62\u5f0f\uff0c\u5176\u8868\u8fbe\u7684\u542b\u4e49\u662f\u4e0d\u53d8\u7684\u3002\u7279\u522b\u6ce8\u610f$\\,G_{-1}=C_{-1}=C_{in}$\u3002     - \u5728\u6211\u4eec\u5f97\u5230column generate\u548cpropagate\u4e4b\u540e\uff0c\u6211\u4eec\u8981\u628a\u5355\u5217\u7ec4\u62102\u5217\u30014\u5217\u7b49\u7b49\uff0c\u4f8b\u5982\u6211\u4eec\u7ec4\u6210\u4e860:-1\uff0c2:1\uff0c4:3\uff0c6:5\uff0c8:7\uff0c10:9\uff0c12:11\uff0c14:13\uff0c\u6211\u4eec\u73b0\u5728\u60f3\u8981\u6765\u6c42\u89e3\u4e24\u5217\u4e24\u5217\u7684generate \u548c propagate\uff0c\u800c\u8fd9\u4e00\u90e8\u5206\u5185\u5bb9\u7684\u5b9e\u73b0\u4f7f\u7528\u7684\u5c31\u662f\u9ed1\u8272\u7535\u8def\uff0c\u5176\u4e2d$\\,P_{i:j}=P_{i:k}P_{k-1:j}$\uff0c$G_{i:j}=G_{i:k}+P_{i:k}G_{k-1:j}$\u3002          \u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u4f1a\u5f97\u5230$\\,G_{2:1},P_{2:1},G_{4:3},P_{4:3},G_{6:5},P_{6:5},G_{8:7},P_{8:7},G_{10:9},P_{10:9},G_{12:11},P_{12:11},G_{14:13},P_{14:13}\\cdots\\,$\u7b49\u7b49\u4e1c\u897f\u3002          \u8fdb\u4e00\u6b65\u6211\u4eec\u4f1a\u5f97\u5230$\\,G_{2:-1},G_{6:3},G_{10:7},G_{14:11},P_{6:3},P_{10:7},P_{14:11}\\cdots\\,$ \u7b49\u7b49\u4e1c\u897f\u3002          \u8fdb\u4e00\u6b65\u6211\u4eec\u4f1a\u5f97\u5230$\\,G_{6:-1},G_{14:7},P_{14:7}\\cdots\\,$\u7b49\u7b49\u4e1c\u897f\u3002          \u8fdb\u4e00\u6b65\u6211\u4eec\u4f1a\u5f97\u5230$G_{14:1}$\u3002          \u4e0e\u6b64\u540c\u65f6\uff0c\u8de8\u5ea6\u4e0d\u4e3a2\u7684\u5e42\u5bf9\u5e94\u7684$\\,G\\,$\u548c$\\,P\\,$\u4e5f\u53ef\u4ee5\u5f88\u5bb9\u6613\u6c42\u5f97\u3002\u5728\u89c6\u9891\u4e2d\u8fd9\u4e9b\u8de8\u5ea6\u4e0d\u4e3a2\u7684\u5e42\u88ab\u79f0\u4e3a\u662fintermediate calculations\uff0c\u4e3e\u4f8b\u6765\u8bf4          $$         \\begin{align*}G_{5:-1}&amp;=G_{5:3}+P_{5:3}G_{2:1}\\\\G_{3:-1}&amp;=G_{3:3}+P_{3:3}G_{2:-1}=G_3+P_3G_{2:-1}\\end{align*}         $$      - \u6700\u4e0b\u9762\u7684\u84dd\u8272\u90e8\u5206\u5176\u5b9e\u5c31\u662f\u7528\u6765\u8ba1\u7b97sum bits\u7684\uff0c\u5b83\u9075\u5faa\u7684\u539f\u5219\u5c31\u662f          $$         S_i=A_i\\oplus B_i\\oplus C_{i-1}=A_i\\oplus B_i\\oplus G_{i-1:-1}         $$      - \u63a5\u4e0b\u6765\u6211\u4eec\u6765\u8003\u8651\u4e00\u4e0b\u5ef6\u65f6\u95ee\u9898:         - \u9996\u5148\u7b2c\u4e00\u6b65\u5c31\u662f\u5f97\u5230\u56fe\u4e2d\u9ec4\u8272\u6240\u793a\u7684\u4fe1\u53f7\uff0c\u5373column propagate\u548ccolumn generate\uff0c\u5373$\\,G_i\\,$\u548c$\\,P_i\\,$\uff0c\u5176\u4e2d$\\,G_i=A_iB_i\\,$\uff0c$P_i=A_i+B_i$\uff0c\u7531\u9ec4\u8272\u90e8\u5206\u7684\u5185\u90e8\u7ed3\u6784\u56fe\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5\u8fd9\u91cc\u5b58\u57281\u4e2a\u62e5\u6709\u4e24\u4e2a\u8f93\u5165\u7aef\u7684AND gate/OR gate delay\u3002         - \u63a5\u4e0b\u6765\u5206\u6790\u9ed1\u8272block\uff0c\u6bcf\u4e00\u4e2arow\u5bf9\u5e94\u7684block\u662f\u540c\u6b65\u7684\uff0c\u7531\u9ed1\u8272block\u7684\u5185\u90e8\u7ed3\u6784\u56fe\u53ef\u4ee5\u5f97\u77e5\u5b83\u7684delay\u662f2\u4e2agates\u3002\u5bf9\u4e8e\u4e24\u4e2a$N$-bit\u7684\u6570\u76f8\u52a0\u7684prefix adder\uff0c\u4e2d\u95f4\u4f1a\u7ecf\u8fc7$\\,\\log_2N\\,$\u8f6e\uff0c\u7c7b\u4f3c\u4e8e\u4e00\u4e2a$\\,8\\to4\\to2\\to1\\,$\u7684\u8870\u51cf\u7684\u8fc7\u7a0b\uff0c\u6bcf\u4e00\u8f6e\u7684delay\u90fd\u662f2\u4e2agates\uff0c\u8fd9\u91cc\u7684\u603bdelay\u53ef\u4ee5\u7528$\\,\\#\\mathrm{stages}\\times \\mathrm{delay\\,of\\,a\\,single\\,stage}$ \u6765\u8ba1\u7b97\u3002         - \u6700\u540e\u5206\u6790\u84dd\u8272\uff0c\u84dd\u8272\u90e8\u5206\u5c31\u662f\u8ba1\u7b97sum bits\u7684\uff0c\u5176\u9075\u5faa\u7684\u539f\u5219\u662f$\\,S_i=A_i\\oplus B_i\\oplus C_{i-1}=A_i\\oplus B_i\\oplus G_{i-1:-1}\\,$\u3002\u8fd9\u4e2a\u84dd\u8272\u90e8\u5206\u7684\u5ef6\u65f6\u662f\u591a\u5c11\uff1f\u770b\u8d77\u6765\u50cf\u662f2 gates\u7684delay\uff0c\u4f46\u4e8b\u5b9e\u4e0a$\\,A_i\\oplus B_i\\,$\u65e9\u5c31\u5df2\u7ecf\u7b97\u597d\u4e86\uff0c\u5728\u8ba1\u7b97$\\,G_i=A_iB_i\\,$\uff0c$P_i=A_i+B_i\\,$\u7684\u65f6\u5019\u5c31\u5df2\u7ecf\u8ba1\u7b97\u5b8c\u6bd5\u4e86\u3002\u6240\u4ee5\u84dd\u8272\u90e8\u5206\u5176\u5b9e\u53ea\u67091 gate delay\u3002         - \u5728\u53f3\u4fa7\u6211\u4eec\u5c31\u5f97\u5230\u4e86prefix adder\u7684delay\u7684\u8ba1\u7b97\u516c\u5f0f              $$             t_{PA}=t_{pg}+\\log_2N(t_{pg\\_prefix})+t_{XOR}             $$              \u5176\u4e2d$\\,t_{pg}\\,$\u5bf9\u5e94\u7684\u662f\u9ec4\u8272\u90e8\u5206\uff0c$\\log_2N(t_{pg\\_prefix})\\,$\u5bf9\u5e94\u7684\u662f\u7eff\u8272\u90e8\u5206\uff0c$t_{XOR}\\,$\u5bf9\u5e94\u7684\u662f\u84dd\u8272\u90e8\u5206\u3002           ![Screenshot 2023-02-07 at 10.57.02.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_10.57.02.png)          ![Screenshot 2023-02-07 at 10.53.15.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_10.53.15.png)          ![Screenshot 2023-02-07 at 11.01.40.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_11.01.40.png)      - In summary, the prefix adder achieves a delay that grows logarithmically rather than linearly with the number of columns in the adder. This speedup is significant, especially for adders with 32 or more bits, but it comes at the expense of more hardware than a simple carry-lookahead adder.     - The network of black cells is called a prefix tree.     - The general principle of using prefix trees to perform computations in time that grows logarithmically with the number of inputs is a powerful technique. With some cleverness, it can be applied to many other types of circuits.     - The critical path for an $N$-bit prefix adder involves the precomputation of $P_i$ and $G_i$ followed by $\\log_2N$ stages of black prefix cells to obtain all the prefixes. $G_{i-1:-1}$ then proceeds through the final XOR gate at the bottom to computer $S_i$. Mathematically, the delay of an $N$-bit prefix adder is          $$         t_{PA}=t_{pg}+\\log_2Nt_{pg\\_prefix}+t_{XOR}         $$          where $t_{pg\\_prefix}$ is the delay of a black prefix cell."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#522-subtraction","title":"5.2.2 Subtraction","text":"\ud83d\udcd6 **Important takeaways**  - Adders can add positive and negative numbers **using two\u2019s complement number representation**. - Subtraction is almost as easy: flip the sig of the second number, then add. - **Flipping the sign** of a two\u2019s complement number is done by **inverting the bits** and **adding 1**. - To compute $Y=A-B$, first create the two\u2019s complement of $B$: Invert the bits of $B$ to obtain $\\overline{B}$ and add 1 to get $-B=\\overline{B}+1$. Add this quantity to $A$ to get $Y=A-B=A+\\overline{B}+1$. This sum can be performed with a single CPA(carry propagate adder) **by adding $A+\\overline{B}$ with $C_{in}=1$**. - Figure 5.9 shows the symbol for a subtractor and the underlying hardware for performing $Y=A-B$.(\u56fe\u4e2d\u5c0f\u7684\u6a2a\u7ebf\u8868\u793a\u63a5\u7535\u6e90\uff0c\u4e5f\u5c31\u662f$C_{in}=\\mathrm{HIGH}=1$)  ![Screenshot 2023-02-07 at 11.23.57.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_11.23.57.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#523-comparators","title":"5.2.3 Comparators","text":"\ud83d\udcd6 **Important takeaways**  - A **comparator** determine **whether two binary numbers are equal** or if **one is greater or less than the other**. - A comparator receives two $N$-bit binary numbers $A$ and $B$. **There are two common types of comparators**.     1. An equality comparator produces a single output indicating whether $A$ is equal to $B$($A==B$).     2. A magnitude comparator produces one or more outputs indicating the relative values of $A$ and $B$.  - **Equality Comparator**     - The equality comparator is the simpler piece of hardware. Figure 5.11 shows the symbol and implementation of a 4-bit equality comparator.     - It first checks to determine whether the corresponding bits in each column of $A$ and $B$ are equal using $\\mathrm{XNOR}$ gates.           | $A_i$ | $B_i$ | $Y$ |         | --- | --- | --- |         | 0 | 0 | 1 |         | 0 | 1 | 0 |         | 1 | 0 | 0 |         | 1 | 1 | 1 |          $$         Y=\\overline{A\\oplus B}         $$      - The numbers are equal if all of the columns are equal.(AND gate)      ![Screenshot 2023-02-07 at 11.38.01.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_11.38.01.png)   - Magnitude comparison is usually done by computing $A-B$ and looking at the sign(most significant bit) of the result as shown in Figure 5.12. - If the result is negative(i.e., the sign bit is 1), then $A$ is less than $B$. Otherwise $A$ is greater than or equal to B.  ![Screenshot 2023-02-07 at 11.48.13.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_11.48.13.png)  ![Screenshot 2023-02-07 at 11.49.38.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_11.49.38.png)  - \u56fe\u4e2d[N-1]\u7684\u610f\u601d\u662f\u4ecebus\u4e2d\u53d6\u51fa\u6700\u9ad8\u4f4d\u3002\u5373\u4ece\u53f3\u5f80\u5de6\u6570\u7b2cN-1\u4f4d\u3002"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#524-alu","title":"5.2.4 ALU(!!!)","text":"\ud83d\udcd6 **Important takeaways**  - An **Arithmetic/Logical Unit(ALU)** **combines a variety of mathematical and logical operations into a single unit**. - For example, **a typical ALU might perform addition, subtraction, magnitude comparison, AND, and OR operations**. - **The ALU form the heart of most computer systems**.  - Figure 5.14 shows the symbol for an $N$-bit ALU with $N$-bit inputs and outputs. **The ALU receives a 2-bit control signal ALUControl that specifies which function to perform**. Control signals will generally be shown in blue to distinguish them from the data. - Table 5.1 lists typical functions that the ALU can perform. - Figure 5.15 shows an implementation of the ALU. The ALU contains an $N$-bit adder and $N$ 2-input AND and OR gates(\u4e24\u4e2a$N$-bit\u7684\u6570\u505aAND\u548cOR\u8fd0\u7b97\u6307\u7684\u662f\u4e24\u4e2a$N$-bit\u6570\u7684\u6bcf\u4e00\u4f4d\u90fd\u505aAND\u548cOR\u8fd0\u7b97). It also contains inverters and a multiplexer to invert input B when $ALUControl_0$ is asserted. A 4:1 multiplexer chooses the desired function based on $ALUControl$.  ![Screenshot 2023-02-07 at 20.43.57.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_20.43.57.png)  - More specifically, **if $ALUControl=00$, the output multiplexer chooses $A+B$**. **If $ALUControl=01$, the ALU computes $A-B$**.(Recall that $\\overline{B}+1=-B$ in two\u2019s complement arithmetic. Because $ALUControl=01, ALUControl_0=1$, the adder receives inputs $A$ and $\\overline{B}$ and an asserted carry in, causing it to perform subtraction: $A-B=A+\\overline{B}+1$\u6ce8\u610f\u4ece$ALUControl$\u4e2d\u5206\u51fa\u6765\u4e86$ALUControl_0$,\u5e76\u4e14$ALUControl_0$\u8fde\u4e86\u4e24\u4e2a\u5730\u65b9,\u4e0a\u65b9\u8fde\u63a5\u7684\u662f\u4e00\u4e2amultiplexer,\u5f53$ALUControl_0=0$\u65f6,\u63a5\u5165\u7684\u4fe1\u53f7\u662f$B$,\u5f53$ALUControl_0=1$\u65f6,\u63a5\u5165\u7684\u4fe1\u53f7\u662f$\\overline{B}$,\u800c\u4e0b\u65b9$ALUControl_0$\u8fd8\u662fadder\u7684carry-in,\u5982\u679c\u662f\u8ba1\u7b97$A+B$,\u6b64\u65f6\u4e0d\u9700\u8981\u521d\u59cb\u7684carry-in,$ALUControl_0=\\text{carry-in}=0$,\u5982\u679c\u662f\u8ba1\u7b97$A-B$,\u56e0\u4e3a$A-B=A+\\overline{B}+1$,\u6240\u4ee5\u6b64\u65f6\u6709\u521d\u59cb\u7684$\\text{carry-in}=ALUControl_0=1$)      If $ALUControl=10$, the ALU computes $A$ $\\mathrm{AND}$ $B$. If $ALUControl=11$, the ALU performs $A$ $OR$ $B$.  - \u8fd9\u6837\u6211\u4eec\u901a\u8fc7\u5de7\u5999\u4f7f\u7528$ALUControl$\u4fe1\u53f7\u4e2d\u7684$ALUControl_0$\u914d\u5408multiplexer,\u4ece\u800c\u9ad8\u6548\u8fbe\u5230\u4e86\u53ea\u4f7f\u7528\u4e00\u4e2aadder\u5c31\u5b8c\u6210\u4e86\u52a0\u6cd5\u51cf\u6cd5\u4e24\u79cd\u8fd0\u7b97\u7684\u6210\u679c\u3002\u56e0\u4e3aadder\u672c\u8eab\u88ab\u6211\u4eec\u8ba4\u4e3a\u662fexpensive\u7684,\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u6784\u5efaadder\u7684\u6210\u672c\u5f88\u9ad8,\u5c3d\u91cf\u4e0d\u8981\u65e0\u7f18\u65e0\u6545\u589e\u52a0adder\u7684\u6570\u91cf,\u53ef\u4ee5\u589e\u52a0\u5176\u5b83\u66f4\u52a0\u7b80\u5355\u7684\u7535\u5b50\u5143\u5668\u4ef6\u3002 - Some ALUs produce extra outputs, called flags, that indicate information about the ALU output. Figure 5.16 shows the ALU symbol with a 4-bit Flags output. - As shown in the schematic of the ALU in Figure 5.17, the Flags output is composed of the N, Z, C, and V flags that indicate, respectively, that the ALU output, Result, is negative(N) or zero(Z) or that the adder produced a carry out(C) or overflowed(V).       | Flag | Description |     | --- | --- |     | N | Result is Negative |     | Z | Result is Zero |     | C | Result produces Carry out |     | V | Adder oVerflowed |      ![Screenshot 2023-02-07 at 21.22.40.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_21.22.40.png)      ![Screenshot 2023-02-07 at 21.24.56.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_21.24.56.png)  - \u63a5\u4e0b\u6765\u6211\u4eec\u5c31\u6765\u8be6\u7ec6\u53d9\u8ff0\u4e00\u4e0b\u8fd9\u56db\u4e2aflags\u90fd\u662f\u5982\u4f55\u5b9e\u73b0\u7684(overflow flag\u56e0\u4e3a\u5185\u5bb9\u6bd4\u8f83\u591a\u5355\u72ec\u5199)     - **N(Negative)**         - \u5224\u65adResult\u662f\u5426\u662f\u8d1f\u6570\u6bd4\u8f83\u7b80\u5355\uff0c\u56e0\u4e3a\u5728two\u2019s complement arithmetic\u4e2d\uff0c\u6700\u9ad8\u4f4d(the most significant bit)\u8868\u5f81\u7684\u4e00\u4e2a\u6570\u7684\u6b63\u8d1f\uff0c\u5f53\u6700\u9ad8\u4f4d(most significant bit, msb)\u662f1\u65f6\uff0c\u8bf4\u660e\u8fd9\u4e2a\u6570\u662f\u8d1f\u6570\uff0c\u5f53\u6700\u9ad8\u4f4d(most significant bit, msb)\u662f0\u65f6\uff0c\u8bf4\u660e\u8fd9\u4e2a\u6570\u662f\u6b63\u6570\u3002         - Negative flag\u7684\u5de5\u4f5c\u539f\u7406\u6bd4\u8f83\u7b80\u5355\uff0c\u5f53negative flag = 1\u65f6\uff0c\u8868\u660e\u7ed3\u679c\u662f\u8d1f\u6570\uff0c\u5f53negative flag = 0\u65f6\uff0c\u8868\u660e\u7ed3\u679c\u662f\u6b63\u6570\u3002         - \u6240\u4ee5 $\\text{negative flag}=\\text{msb}=Result_{31}$.     - **Z(Zero)**         - Zero flag\u7684\u5de5\u4f5c\u539f\u7406\u6bd4\u8f83\u7b80\u5355\uff0c\u5f53zero flag = 1\u65f6\uff0c\u8868\u660e\u7ed3\u679c\u662f0\uff0c\u5f53zero flag = 0\u65f6\uff0c\u8868\u660e\u7ed3\u679c\u4e0d\u662f0\u3002         - \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5bf9\u7ed3\u679c\u6309\u4f4d\u53d6\u53cd\uff0c\u7136\u540eAND\u5728\u4e00\u8d77\uff0c\u56e0\u4e3a\u53ea\u6709\u5f53\u7ed3\u679c\u4e3a0(\u6bcf\u4e00\u4f4d\u90fd\u662f0)\u65f6\uff0c\u5bf9\u5176\u6309\u4f4d\u53d6\u53cd\uff0c\u624d\u4f1a\u6bcf\u4e00\u4f4d\u90fd\u662f1\uff0c\u53ea\u6709\u5f53\u6bcf\u4e00\u4f4d\u5168\u662f1\u7684\u60c5\u51b5\u4e0b\uff0c\u5c06\u5176AND\u5728\u4e00\u8d77\uff0c\u7ed3\u679c\u624d\u4f1a\u662f1\u3002         - \u6240\u4ee5\u6211\u4eec\u5728\u5b9e\u9645\u642d\u5efa\u7535\u8def\u7684\u65f6\u5019\u4f1a\u6709\u4e00\u4e2a\u5c0f\u5706\u5708\u8868\u793a\u53d6\u53cd\uff0c\u7136\u540e\u7edf\u4e00\u7ecf\u8fc7\u4e00\u4e2aAND gate\u3002     - **C(Carry)**         - Carry flag\u7684\u5de5\u4f5c\u539f\u7406\u6bd4\u8f83\u7b80\u5355\uff0c\u5f53$\\,C_{out}=1\\,$\u65f6\uff0c\u8bf4\u660e\u6700\u540e\u662f\u6709\u8fdb\u4f4dcarry\u7684\uff0c\u56e0\u6b64\u6b64\u65f6carry flag = 1\u3002\u5f53$\\,C_{out}=0\\,$\u65f6\uff0c\u8bf4\u660e\u6700\u540e\u65f6\u6ca1\u6709\u8fdb\u4f4dcarry\u7684\uff0c\u56e0\u6b64\u6b64\u65f6carry flag = 0\u3002         - \u6211\u4eec\u5224\u65adcarry\u7684\u65f6\u5019\u662f\u8981\u5728ALU\u5904\u4e8e\u8ba1\u7b97\u52a0\u6cd5\u6a21\u5f0f\u548c\u51cf\u6cd5\u6a21\u5f0f\u7684\u65f6\u5019\uff0c\u7531\u4e8e\u52a0\u6cd5\u6a21\u5f0f\u5bf9\u5e94\u7684\u72b6\u6001\u662f$ALUControl=00$\uff0c\u51cf\u6cd5\u6a21\u5f0f\u5bf9\u5e94\u7684\u72b6\u6001\u662f$ALUControl=01$\u3002         - \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8ba9              $$             carry\\,flag=\\overline{ALUControl_1}\\space\\text{AND}\\space C_{out}             $$   ![Screenshot 2023-02-07 at 20.22.39.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_20.22.39.png)  ![Screenshot 2023-02-07 at 20.19.01.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_20.19.01.png)  [Logic Gates - Building an ALU](http://www.csc.villanova.edu/~mdamian/Past/csc2400fa13/assign/ALU.html)  ![Screenshot 2023-02-07 at 20.40.11.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_20.40.11%201.png)  ![Screenshot 2023-02-07 at 20.42.26.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_20.42.26.png)  ![Screenshot 2023-02-07 at 20.42.58.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_20.42.58.png)  ![Screenshot 2023-02-07 at 21.22.01.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_21.22.01.png)  ![Screenshot 2023-02-07 at 21.31.23.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_21.31.23.png)  ![Screenshot 2023-02-07 at 21.31.29.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_21.31.29.png)  ![Screenshot 2023-02-07 at 21.31.31.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_21.31.31.png)  ![Screenshot 2023-02-07 at 21.31.33.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_21.31.33.png)  ![Screenshot 2023-02-07 at 21.31.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-07_at_21.31.36.png)  - **V(overflow)**     - Overflow\u7684\u57fa\u672c\u601d\u60f3\u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u662f\u51fa\u73b0overflow\u7684\u65f6\u5019\uff0coverflow flag = 1\uff0c\u6ca1\u6709\u51fa\u73b0overflow\u7684\u65f6\u5019\uff0coverflow flag = 0\u3002     - \u56e0\u6b64\u6211\u4eec\u73b0\u5728\u5c31\u8981\u6765\u7740\u91cd\u5206\u6790\u5230\u5e95\u5728\u4ec0\u4e48\u60c5\u51b5\u4e0b\u4f1a\u51fa\u73b0overflow\u3002     - **\u9996\u5148\u4e0ecarry flag\u7684\u5224\u65ad\u4e00\u6837\uff0c\u6211\u4eec\u7684\u4e00\u4e2a\u524d\u63d0\u662fALU\u6b63\u5728\u8fdb\u884c\u52a0\u6cd5\u8fd0\u7b97\u6216\u51cf\u6cd5\u8fd0\u7b97**\u3002     - \u5176\u6b21\u5c31\u662f\u8981\u68c0\u67e5\u662f\u5426\u6709overflow\uff0c\u8981\u60f3**\u6709overflow\u7684\u4e00\u4e2a\u5fc5\u8981\u6761\u4ef6\u5c31\u662fA\u548cSum\u6709\u76f8\u53cd\u7684\u7b26\u53f7**\u3002\u4e3a\u4ec0\u4e48\u8fd9\u4e48\u8bf4\uff0c\u6211\u4eec\u4e0d\u59a8\u601d\u8003\u4e00\u4e0b\u4ec0\u4e48\u65f6\u5019\u4f1a\u53d1\u751foverflow\u3002         - \u4e00\u6b63\u4e00\u8d1f\u505a\u52a0\u6cd5\u4e0d\u4f1aoverflow\uff0c\u4e24\u4e2a\u6b63\u505a\u51cf\u6cd5\u4e0d\u4f1aoverflow\uff0c\u4e24\u4e2a\u8d1f\u505a\u51cf\u6cd5\u4e0d\u4f1aoverflow\u3002         - \u4e24\u4e2a\u6b63\u505a\u52a0\u6cd5\u6709\u53ef\u80fdoverflow\uff0c\u4e24\u4e2a\u8d1f\u505a\u52a0\u6cd5\u6709\u53ef\u80fdoverflow\uff0c\u4e00\u4e2a\u6b63\u4e00\u4e2a\u8d1f\u505a\u51cf\u6cd5\u6709\u53ef\u80fdoverflow\uff0c\u4e00\u4e2a\u8d1f\u4e00\u4e2a\u6b63\u505a\u51cf\u6cd5\u6709\u53ef\u80fdoverflow\u3002         - \u4e24\u4e2a\u6b63\u505a\u52a0\u6cd5overflow\u7684\u65f6\u5019\uff0cA\u7684sign bit\u662f0\uff0csum\u7684sign bit \u662f1\u3002         - \u4e24\u4e2a\u8d1f\u505a\u52a0\u6cd5overflow\u7684\u65f6\u5019\uff0cA\u7684sign bit\u662f1\uff0csum\u7684sign bit\u662f0\u3002         - \u4e00\u6b63\u4e00\u8d1f\u505a\u51cf\u6cd5overflow\u7684\u65f6\u5019\uff0cA\u7684sign bit\u662f0\uff0csum\u7684sign bit\u662f1\uff0c\u4f8b\u5982              $1-(-7)=0001-1001=0001+0111=1000(overflow)$.          - \u4e00\u8d1f\u4e00\u6b63\u505a\u51cf\u6cd5overflow\u7684\u65f6\u5019\uff0cA\u7684sign bit\u662f1\uff0csum\u7684sign bit\u662f0\uff0c\u4f8b\u5982              $-7-3=1001-0011=1001+1101=0110(overflow)$.          - **A\u548cSum\u7684\u7b26\u53f7(\u770b\u7684\u5c31\u662fsign bit)\u5982\u679c\u76f8\u53cd\uff0c\u8f93\u51fa1\uff0c\u76f8\u540c\uff0c\u8f93\u51fa0\uff0c\u8fd9\u53ef\u4ee5\u7528XOR gate\u6765\u5b9e\u73b0**\u3002     - \u6700\u540e\u5149\u8ba9A\u548cSum\u6709\u76f8\u53cd\u7684\u7b26\u53f7\u662f\u4e0d\u591f\u7684\uff0c\u56e0\u4e3a\u6709\u53ef\u80fd\u51fa\u73b0         - \u6b63+\u8d1f=\u8d1f\uff0c\u8d1f+\u6b63=\u6b63\uff0c\u6b63-\u6b63=\u8d1f\uff0c\u8d1f-\u8d1f=\u6b63\u7684\u60c5\u51b5\uff0c\u5728\u8fd9\u56db\u79cd\u60c5\u51b5\u4e2d\uff0c\u867d\u7136A\u548cSum\u6709\u76f8\u53cd\u7684sign bit\uff0c\u4f46\u662f\u5e76\u4e0d\u4f1a\u53d1\u751foverflow\u3002         - \u56e0\u6b64\u6211\u4eec\u9700\u8981\u8fdb\u4e00\u6b65\u9650\u5b9a\uff0cA\u548cSum\u6709\u76f8\u53cd\u7684\u7b26\u53f7\uff0c\u4e14\u5fc5\u987b\u5904\u5728A\u3001B\u540c\u53f7\u5e76\u8fdb\u884c\u52a0\u6cd5\u8fd0\u7b97\uff0c\u6216A\u3001B\u5f02\u53f7\u5e76\u8fdb\u884c\u51cf\u6cd5\u8fd0\u7b97\u4e24\u79cd\u60c5\u51b5\u3002\u8fd9\u5206\u522b\u5bf9\u5e94\u56fe\u7247\u4e2d\u5199\u5230\u7684             - A and B have same signs for addition.             - A and B have different signs for subtraction.         - \u6240\u4ee5\u6211\u4eec\u7b2c\u4e09\u4e2a\u6761\u4ef6\u6709\u5982\u4e0b\u7684\u8981\u6c42             - add(00)\uff0csame sign(same sign bit)\uff0c\u6709000\uff0c011\u4e24\u79cd\u7ec4\u5408\u65b9\u5f0f\u3002             - subtract(01)\uff0cdifferent sign(different sign bit)\uff0c\u6709101\uff0c110\u4e24\u79cd\u7ec4\u5408\u65b9\u5f0f\u3002             - \u7ec4\u5408\u65b9\u5f0f\u662f$ALUControl_0+sign\\,bit\\,1+sign\\,bit\\,2$\u3002             - \u8981\u6c42\u5728\u4e0a\u8ff0\u51e0\u79cd\u7ec4\u5408\u65b9\u5f0f\u4e0b\u8f93\u51fa1\uff0c\u5176\u4f59\u7ec4\u5408\u65b9\u5f0f\u8f93\u51fa0\u3002             - \u7ecf\u8fc7\u89c2\u5bdf\uff0c\u53d1\u73b0\u5e94\u8be5\u4f7f\u7528XNOR gate(\u6709\u5076\u6570\u4e2a1\u5219\u8f93\u51fa1\uff0c\u6709\u5947\u6570\u4e2a1\u5219\u8f93\u51fa0\uff0c\u6ce8\u610fXNOR gate\u4e0eXOR gate\u4e4b\u95f4\u7684\u533a\u522b\uff0cXOR gate\u662f\u6709\u5947\u6570\u4e2a1\u8f93\u51fa1\uff0c\u6709\u5076\u6570\u4e2a1\u8f93\u51fa0)\u3002     - \u6700\u540e\u6211\u4eec\u5b9e\u73b0V(overflow flag)\u8fd8\u9700\u8981\u4e09\u5251\u5408\u4e00         1. \u5904\u4e8e\u52a0\u6cd5\u8fd0\u7b97\u6216\u51cf\u6cd5\u8fd0\u7b97\u6a21\u5f0f($\\overline{ALUControl_1}$)         2. A\u4e0eSum\u7684sign bit\u76f8\u53cd\u3002($A_{31}\\,\\text{XOR}\\,Sum_{31}$)         3. A\u3001B\u7b26\u53f7\u76f8\u540c\uff0c\u4e14\u8fdb\u884c\u7684\u662f\u52a0\u6cd5\u8fd0\u7b97\u6216A\u3001B\u7b26\u53f7\u76f8\u53cd\u4e14\u8fdb\u884c\u7684\u51cf\u6cd5\u8fd0\u7b97\u3002          $$         A_{31}\\space\\text{XNOR}\\space B_{31}\\space\\text{XNOR}\\space ALUControl_0=\\overline{A_{31}\\oplus B_{31}\\oplus ALUControl_0}         $$"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#53-number-systems","title":"5.3 Number Systems","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#530-background","title":"5.3.0 Background","text":"\ud83d\udcd6 **Background**  - **Computers operate on both integers and fractions**. - So far, we have only considered representing signed or unsigned integers, as introduced in Section 1.4. - This section introduces **fixed- and floating-point number systems** that can **represent rational numbers**. - Fixed-point numbers are analogous to decimals; some of the bits represent the integer part, and the rest represent the fraction. - Floating-point numbers are analogous to scientific notation, with a mantissa(?) and an exponent."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#531-fixed-point-number-systems","title":"5.3.1 Fixed-Point Number Systems","text":"\ud83d\udcd6 **Important takeaways**  - **Fixed-point notation** has an **implied binary point** between the integer and fraction bits, **analogous to the decimal point** between the integer and fraction digits of an ordinary decimal number. - For example,     - Figure 5.23(a) shows a fixed-point number with **four integer bits and four fraction bits**.     - Figure 5.23(b) shows **the implied binary point in blue**.     - Figure 5.23(c) shows the equivalent decimal value. - Signed(positive and negative) fixed-point numbers can use either two\u2019s complement or sign/magnitude notation. - Figure 5.24 shows the fixed-point representation of -2.375 using both notations with four integer and four fraction bits. The implicit binary point is shown in blue for clarity. - In **sign/magnitude form**, the **most significant bit is used to indicate the sign**(1 for negative numbers and 0 for positive numbers). - The **two\u2019s complement representation** is formed by **inverting the bits of the absolute value and adding a 1 to the least significant (rightmost) bit**. In this case, **the least significant bit position is in the $2^{-4}$ column**. - Like all binary number representations, fixed-point numbers are just a collection of bits. There is no way of knowing the existence of the binary point except through agreement of those people interpreting the number. - In general, we use $Ua.b$ to denote an unsigned fixed-point number with $a$ integer bits and $b$ fraction bits. $Qa.b$ denotes a signed(two\u2019s complement) fixed point number with $a$ integer bits(including the sign bit) and $b$ fractional bits.  ![Screenshot 2023-02-08 at 00.05.59.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-08_at_00.05.59.png)  ![Screenshot 2023-02-08 at 00.09.30.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-08_at_00.09.30.png)  ![Screenshot 2023-02-08 at 00.24.44.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-08_at_00.24.44.png)  ![Screenshot 2023-02-08 at 00.24.58.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-08_at_00.24.58.png)  ![Screenshot 2023-02-08 at 00.24.08.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-08_at_00.24.08.png)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#532-floating-point-number-systems","title":"5.3.2 Floating-Point Number Systems","text":"\ud83d\udcd6 **Important takeaways**  -"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#6-architecture","title":"6 Architecture","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#61-introduction","title":"6.1 Introduction","text":"\ud83d\udcd6 **Background**  - The previous chapters introduced digital design principles and building blocks. In this chapter, we **jump up a few levels of abstraction** to **define the architecture of a computer**. The **architecture is the programmer\u2019s view of a computer**. It is defined by the **instruction set(language)** and **operand locations(registers and memory)**. Many different architectures exist, such as RISC-V, ARM, x86, MIPS, SPARC, and POWERPC. - The **first step** in **understanding any computer architecture** is to **learn its language**. The words in a computer\u2019s language are called **instructions**. The computer\u2019s vocabulary is called the **instruction set**. All programs running on a computer use the same instruction set. - **Computer instructions** indicate **both the operation** to perform **and the operands** to use. The **operands** may **come from memory**, **from registers, or from the instruction** itself. - Humans consider reading machine language to be tedious, so we prefer to **represent the instructions in a symbolic format** called **assembly language**. - The instruction sets of different architectures are more like different dialects than different languages. **Almost all architectures define basic instructions, such as add, subtract, and jump, that operate on memory or registers**. - **A computer architecture does not define the underlying hardware implementation**. Often, many different hardware implementations of a single architecture exist. - The specific arrangement of registers, memories, ALUs, and other building blocks to form a microprocessor is called the microarchitecture and will be the subject of Chapter 7. Often, many microarchitectures exist for a single architecture. - In this text, we introduce the MIPS architecture that was first developed by John Hennessy and his colleagues at Stanford in the 1980s. MIPS processors are used by, among others, Silicon Graphics, Nintendo, and Cisco. - We start by introducing the **basic instructions**, **operand locations**, and **machine language formats**. We then introduce **more instructions used in common programming concepts, such as branches, loops, array manipulations, and function calls**.  ![Screenshot 2023-02-08 at 22.30.37.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-08_at_22.30.37.png)  ![Screenshot 2023-02-08 at 22.30.58.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-08_at_22.30.58.png)  - Throughout the chapter, we motivate the design of the MIPS architecture using **four principles** articulated by Patterson and Hennessy:     1. **simplicity favors regularity**     2. **make the common case fast**     3. **smaller is faster**     4. **good design demands good compromises**"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#62-assembly-language","title":"6.2 Assembly Language","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#620-background","title":"6.2.0 Background","text":"\ud83d\udcd6 **Background**  - Assembly language is the human-readable representation of the computer\u2019s native language. - Each **assembly language instruction** specifies both **the operation to perform** and **the operand on which to operate**. - We introduce simple arithmetic instructions and show how these operations are written in assembly language. We then define the MIPS instruction operands: registers, memory, and constants.(\u8fd9\u4e9b\u90fd\u662f\u8fd0\u7b97operation\u4f5c\u7528\u7684\u5bf9\u8c61)"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#621-instructions","title":"6.2.1 Instructions","text":"\ud83d\udcd6 **Important takeaways**  - The most common operation computers perform is addition. The first part of the assembly instruction, `add`, is called the **mnemonic** and **indicates what operation to perform**. The operation is performed on `b` and `c` , the **source operands**, and the result is written to `a` , the **destination operands**.       ```c     a = b + c     ```      ```nasm     add a, b, c     ```  - Subtraction is similar to addition. The instruction format is the same as the `add` instruction except for the operation specification, `sub`. This consistent instruction format is an example of the first design principle:      $$     \\mathrm{\\bold{Design\\space Principle\\space1}:Simplicity\\space favors\\space regularity}     $$  - In assembly language, only single-line comments are used. They begin with `#` and continue until the end of the line. - Instructions with a consistent number of operands \u2014 in this case, two sources and one destination \u2014 are easier to encode and handle in hardware. **More complex high-level code translates into multiple MIPS instructions**.       ```c     a = b + c - d      ```      ```nasm     sub t, c, d  # t = c - d     add a, b, t  # a = b + t = b + c - d     ```      Using multiple assembly language instructions to perform more complex operations is an example of the second design principle of computer architecture:      $$     \\mathrm{\\bold{Design\\space Principle\\space2}:Make\\space the\\space common\\space case\\space fast}     $$  - **The MIPS instruction set makes the common case fast by including only simple, commonly used instructions**. The number of instructions is kept small so that the hardware required to decode the instruction and its operand can be simple, small, and fast. - More elaborate operations that are less common are performed using sequences of multiple simple instructions. Thus, **MIPS is a reduced instruction set computer(RISC)** architecture. Architectures with many complex instructions, such as Intel\u2019s x86 architecture, are complex instruction set computers(CISC). - A RISC architecture minimizes the hardware complexity and the necessary instruction encoding by keeping the set of distinct instructions small. For example, an instruction set with 64 simple instructions would need $\\log_264=6$ bits to encode the operation. An instruction set with 256 complex instructions would need $\\log_2256=8$ bits of encoding per instruction. In a CISC machine, even though the complex instructions may be used only rarely, they add overhead to all instructions, even the simple ones."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/#622-operands-registers-memory-and-constants-load-wordlw-store-wordsw","title":"6.2.2 Operands: Registers, Memory, and Constants(\u2757\u2757\u2757\u2757\u2757\u00a0load word[lw], store word[sw])","text":"\ud83d\udcd6 **Important takeaways**  - **Background**     - An instruction operates on operands. In `add a, b, c` , the variables `a` , `b` , and `c` are all operands. But computers operate on 1\u2019s and 0\u2019s, not variable names. The instruction need a physical location from which to retrieve the binary data.     - Operands can be stored in registers or memory, or they may be constants stored in the instruction itself.     - Computers use **various locations** to **hold operands** in order to **optimize for speed and data capacity**.         - Operands stored as constants or in registers are accessed quickly, but they hold only a small amount of data.         - Additional data must be accessed from memory, which is large but slow.     - MIPS is called a 32-bit architecture because it operates on 32-bit data. - **Registers**     - Instructions need to access operands quickly so that they can run fast. But operands stored in memory take a long time to retrieve.     - Therefore, most architectures **specify a small number of registers** that **hold commonly used operands**.     - The MIPS architecture uses 32 registers, called the register set or register file. The fewer the registers, the faster they can be accessed. This leads to the third design principle:          $$         \\mathrm{\\bold{Design\\space Principle\\space3}:Smaller\\space is\\space faster}         $$      - Looking up information from a small number of relevant books on your desk is a lot faster than searching for the information in the stacks at a library. Likewise, reading data from a small set of registers(for example, 32) is faster than reading it from 1000 registers or a large memory.     - (?) A small register file is typically built from a small SRAM array(see Section 5.5.3). The SRAM array uses a small decoder and bitlines connected to relatively few memory cells, so it has a shorter critical path than a large memory does.     - The following example shows the `add` instruction with register operands. MIPS register names are preceded by the `$` sign. The variable `a`, `b`, and `c` are arbitrarily placed in `$s0`, `$s1`, `$s2`. The name `$s1` is pronounced \u201cregister `s1`\u201d or \u201cdollar `s1`\u201d, The instruction adds the 32-bit values contained in `$s1`(`b`) and `$s2`(`c`) and writes the 32-bit result to `$s0`(`a`).           ```c         a = b + c         ```          ```nasm         add $s0, $s1, $s2         ```      - MIPS generally stores variables in 18 of the 32 registers: `$s0`-`$s7`, and `$t0`-`$t9`.         - Register names beginning with `$s` are called saved registers. Following MIPS convention, these registers store variables such as `a`, `b`, and `c`. Saved registers have special connotations when they are used with function calls(see Section 6.4.6).         - Register names beginning with `$t` are called temporary registers. They are used for storing temporary variables. The following example shows MIPS assembly code using a temporary register, `$t0` , to store the intermediate calculation of `c - d`.               ```c             a = b + c - d             ```              ```nasm             sub $t0, $s2, $s3 # t = c - d             add $s0, $s1, $t0 # a = b + t = b + c - d             ```              ![Screenshot 2023-02-08 at 23.56.43.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-08_at_23.56.43.png)              ```nasm             sub $s0, $s1, $s2 # a = b - c             add $t0, $s4, $s5 # $t0 = g + h             add $t1, $s6, $s7 # $t1 = i + j             sub $s3, $t0, $t1 # f = (g + h) - (i + j)             ```  - **The Register Set**       - The MIPS architecture defines 32 registers. Each register has a name and a number ranging from 0 to 31. Table 6.1 lists the name, number, and use for each register.     - `$0` always contain the value `0` because this constant is so frequently used in computer programs.     - We have also discussed the `$s` and `$t` registers. The remaining registers will be described throughout this chapter.      ![Screenshot 2023-02-09 at 00.02.45.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-09_at_00.02.45.png)  - **Memory**     - If registers were the only storage space for operands, we would be confined to simple programs with no more than 32 variables. However, data can also be stored in memory.     - When compared to the register file, **memory has many data locations**, but **accessing it takes a longer amount of time**.     - Whereas the register file is small and fast, memory is large and slow. For this reason, **commonly used variables are kept in registers**.           |  | the register file | memory |         | --- | --- | --- |         | data locations | limited data locations(only 32 registers) | many data locations |         | time to access the data | shorter | longer |     - By using a combination of memory and registers, a program can access a large amount of data fairly quickly.     - (?) As described in Section 5.5, memories are organized as an array of data words.     - **The MIPS architecture uses 32-bit memory addresses and 32-bit data words**.     - **MIPS uses a byte-addressable memory**. That is, each byte in memory has a unique address. However, for explanation purposes only, we first introduce a word-addressable memory, and afterwards describe the MIPS byte addressable memory.     - Figure 6.1 shows a memory array that is word-addressable. That is, each 32-bit data word has a unique 32-bit address. **Both the 32-bit word address and the 32-bit data value are written in hexadecimal in Figure 6.1**. For example, data `0xF2F1AC07` is stored at memory address `1`. Hexadecimal constants are written with the prefix `0x`. By convention, memory is drawn with low memory address toward the bottom and high memory address toward the top.     - MIPS uses the load word, `lw`, to read a data word from memory into a register. Code Example 6.6 loads memory word `1` into `$s3`. The `lw` instruction specifies **the effective address in memory** as **the sum of a base address and an offset**.         - The base address(written in parentheses in the instruction) is a register(e.g., `$0`).         - The offset is a constant(written before the parentheses).         - In Code Example 6.6, the base address is `$0`, which holds the value `0`, and the offset is `1` , so the `lw` instruction reads from memory address `($0 + 1) = 1`. After the load word instruction(`lw`) is executed, `$s3` holds the value `0xF2F1AC07`, which is the data value stored at memory address `1` in Figure 6.1.         - Similarly, MIPS uses the store word instruction, `sw`, to write a data word from a register into memory(`lw` reads a data from the memory into a register). Code Example 6.7 writes the contents of register `$s7` into memory word `5`.         - These examples have used `$0` as the base address for simplicity, but remember that any register can be used to supply the base address.          ![Screenshot 2023-02-09 at 00.11.28.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-09_at_00.11.28.png)          ![Screenshot 2023-02-09 at 00.12.03.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-09_at_00.12.03.png)          ![Screenshot 2023-02-09 at 00.12.17.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-09_at_00.12.17.png)      - The previous two code examples have shown a computer architecture with a word-addressable memory. **The MIPS memory model, however, is byte-addressable, not word-addressable**. **Each data byte has a unique address**.     - A 32-bit word consists of four 8-bit bytes,$\\,32\\,\\mathrm{bits}=4\\times8\\,\\mathrm{bits}$. **So each word address is a multiple of 4**, as shown in in Figure 6.2. Again, both the 32-bit word address and the data value are given in hexadecimal.     - Code Example 6.8 shows how to read and write words in the MIPS byte-addressable memory. **The word address is four times the word number**. The MIPS assembly code reads words 0, 2, 3 and writes words 1, 8, and 100. **The offset can be written in decimal or hexadecimal**.          $$         \\begin{align*}0_{10}\\times4&amp;=0_{10}=0_{16}\\\\2_{10}\\times 4&amp;=8_{10}=8_{16}\\\\3_{10}\\times 4&amp;=12_{10}=\\mathrm{0xC}_{16}\\end{align*}         $$          $$         \\begin{align*}4_{10}\\div4&amp;=1_{10}\\\\0\\mathrm{x20}_{16}\\div 4&amp;=32_{10}\\div 4=8_{10}\\\\400_{10}\\div 4&amp;=100\\end{align*}         $$          ![Screenshot 2023-02-09 at 00.31.36.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-09_at_00.31.36.png)          ![Screenshot 2023-02-09 at 00.31.54.png](Digital%20Design%20and%20Computer%20Architecture(!!!)%20935ed377ae204d42b7648117d32f3ac2/Screenshot_2023-02-09_at_00.31.54.png)      - The MIPS architecture also provides the `lb` and `sb` instructions that load and store single bytes in memory rather than words. They are similar to `lw` and `sw` and will be discusses further in Section 6.4.5.     - Byte-addressable memories are organized in a big-endian or little-endian fashion, as shown in Figure 6.3."},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2010%20eb97c06954a04afb99ae01d4a51f7bc4/","title":"Exercises 1.10","text":"<p>Correctness: AC Tags: largest, sign/magnitude, two's complement, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2011%202470c3e6ea2247e3891c90d1d937d57b/","title":"Exercises 1.11","text":"<p>Correctness: AC Tags: sign/magnitude, smallest, two's complement, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2012%20e4a29214a0a046abbd796833f514b1b3/","title":"Exercises 1.12","text":"<p>Correctness: AC Tags: sign/magnitude, smallest, two's complement, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2013%2088c6ac38eb7a4a8dbe405d8ed36c1f6d/","title":"Exercises 1.13","text":"<p>Correctness: AC Tags: 2 to 10, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2014%205848d6963cdf403388c23f9575aeef6c/","title":"Exercises 1.14","text":"<p>Correctness: AC Tags: 2 to 10, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2015%20d52eb013fc324970b7fb0a5eed9b22f4/","title":"Exercises 1.15","text":"<p>Correctness: AC Tags: 2 to 16, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2016%209c0a504f498b4ef4a71bb108cf87fe62/","title":"Exercises 1.16","text":"<p>Correctness: WA Tags: 2 to 16, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2017%20c238149df31440b18aaf2f477472826e/","title":"Exercises 1.17","text":"<p>Correctness: WA Tags: 16 to 10, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2018%20ee81733299b241fe9c693ca7ca2e92e6/","title":"Exercises 1.18","text":"<p>Correctness: AC Tags: 16 to 10, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2019%20be390edc87fc4bd6a34e9281de12fd21/","title":"Exercises 1.19","text":"<p>Correctness: AC Tags: 16 to 2, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2020%20b740d9dd1bf24ad28643f0345ebe1110/","title":"Exercises 1.20","text":"<p>Correctness: AC Tags: 16 to 2, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2021%20e2e62e6b32154fb8ace582f3325dc827/","title":"Exercises 1.21","text":"<p>Correctness: AC Tags: 2 to 10, two's complement</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2022%20c4ed318b8f4e4f5e88286c6f9fd57284/","title":"Exercises 1.22","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2023%206abd4ff4f34642a080f6d74f03a3978d/","title":"Exercises 1.23","text":"<p>Correctness: AC Tags: 2 to 10, sign/magnitude</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2024%203856d2317d1b4f478fa6dfe6d50d333f/","title":"Exercises 1.24","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2025%208a9ee3fa7b65420c915a9ef59f2a8966/","title":"Exercises 1.25","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2026%20e0742cd464cd4d00b03254bdae747197/","title":"Exercises 1.26","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2027%202aa06ba608174e089c9996675cb6371c/","title":"Exercises 1.27","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2028%207a39d73323c64c85844b61b3256567f3/","title":"Exercises 1.28","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2029%20ef0ad6558e06485b88499ce21bdead27/","title":"Exercises 1.29","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2030%205395e3a52b7549178c492a75a6c73869/","title":"Exercises 1.30","text":"<p>Correctness: AC Tags: 10 to 2, overflow, two's complement</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2031%203b868a7b556849a096ef76d2c3d5d5f6/","title":"Exercises 1.31","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2032%200f6c5334043a4a709304a9afd32baa15/","title":"Exercises 1.32","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2033%20a88e0dc63af3479d8f7dd78b688f817b/","title":"Exercises 1.33","text":"<p>Correctness: AC Tags: sign extension, two's complement</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2034%20a51d07d672b648bf9084c4f5561fcade/","title":"Exercises 1.34","text":"<p>Correctness: AC Tags: sign extension, two's complement</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2035%208b202192a2cb481baecaffc0f4026234/","title":"Exercises 1.35","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2036%204180a60d4ec247dbb7f118f3a0745771/","title":"Exercises 1.36","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2037%20ddd1e130ee3b4d0c938de29980a0f2b2/","title":"Exercises 1.37","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2038%209dcc63eb41604125ab26b2d15d3139c3/","title":"Exercises 1.38","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2039%20828be2e26825457fa2c428122d861427/","title":"Exercises 1.39","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2040%2077ee90b34ecf45a9890c128b33a0cdb5/","title":"Exercises 1.40","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2041%206331cf415ae44d549b9817d47e36e5a8/","title":"Exercises 1.41","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2042%20b15be9a043514a2f833a07f23dadc2f0/","title":"Exercises 1.42","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2043%20ceb4bca019704340a058557b5520ffe9/","title":"Exercises 1.43","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2044%20a56d0ea66fbf4cf8a69e35cf9fcfa7d3/","title":"Exercises 1.44","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2045%205aaf25cf48584ddf8b9fa51d0528699a/","title":"Exercises 1.45","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2046%203582cbcb8d2e406e8dd084b03ba189aa/","title":"Exercises 1.46","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2047%20e042d3907cd346f0935ff80ccea94a17/","title":"Exercises 1.47","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2048%20b287524da7784998a0e1f01b9dc1d5e7/","title":"Exercises 1.48","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2049%20ce6aba5bd6c54bd4bf00edc8eccdd3fc/","title":"Exercises 1.49","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2050%20fbf0963aac8d48578383ff7db699d65d/","title":"Exercises 1.50","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2051%20e954da8d73184833b14cd3673e8eca49/","title":"Exercises 1.51","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2052%20af2c88a5cb524a6ca49703fbcd649139/","title":"Exercises 1.52","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2053%20444db9a1e08c4d63a338dec15d0fb3b5/","title":"Exercises 1.53","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2054%20a4e8e560a999440699d744cca1c184c4/","title":"Exercises 1.54","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2055%200c1684b93a224bea868bde038edab9c9/","title":"Exercises 1.55","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%2056%20c9817533db894102ad31406ad2b4789f/","title":"Exercises 1.56","text":"<p>Correctness: AC Tags: overflow, sum, two's complement</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%206%207e227b1c17604545a91e0f0d56baa02b/","title":"Exercises 1.6","text":"<p>Correctness: AC Tags: base 60</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%207%20bd1806833e3c4672a09c08ec65a3895d/","title":"Exercises 1.7","text":"<p>Correctness: AC Tags: bits</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%208%20849cf49f510949e7bab1a0d143d20c79/","title":"Exercises 1.8","text":"<p>Correctness: AC Tags: bits, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Exercises%201%209%20fd6964faad4345b8a9a8902674a01829/","title":"Exercises 1.9","text":"<p>Correctness: AC Tags: bits, sign/magnitude, two's complement, unsigned</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%201%20Checklist%209739faeb07f34d1ca5054be6c77d32a4/Untitled%205331123057ec42a2a8ff2eb6e333da81/","title":"Untitled","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%201%2083ec2d7f79084726bd92446b1cb182b2/","title":"Exercises 2.1","text":"<p>Correctness: AC Tags: sum-of-products canonical form</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2010%201e9703ae525348ad9c1b40b57a82e478/","title":"Exercises 2.10","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2011%20aca3b6390dd741ccac3e7db77844b7f1/","title":"Exercises 2.11","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2012%20b6c09feb9ffb4e92aeff7364d361523f/","title":"Exercises 2.12","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2013%20d18a37541b7d4a70b18f17bd1398321a/","title":"Exercises 2.13","text":"<p>Correctness: WA Tags: K-map, boolean theorem, simplify boolean equations</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2014%20040bcd97528f43f19c9d8a08bed39278/","title":"Exercises 2.14","text":"<p>Correctness: AC Tags: K-map, boolean theorem, simplify boolean equations</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2015%20185e9af05dd048d1a9d8ff7431fa1fea/","title":"Exercises 2.15","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2016%200b0ce076ae1448278c1014ad01cfe2b1/","title":"Exercises 2.16","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2017%203d5b02c34e5744b084ae154aea0c37ef/","title":"Exercises 2.17","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2018%207c266bbd135a49e886bad59da63c258e/","title":"Exercises 2.18","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2019%20a53c1f37ae48499b81d200b738d55b0d/","title":"Exercises 2.19","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%202%20bcea0f249c834108af70a54b3a713541/","title":"Exercises 2.2","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2020%20936a963cfead4b14b265cc9521623fa7/","title":"Exercises 2.20","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2021%2043f03d158d134c38b8c261f904752b59/","title":"Exercises 2.21","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2022%205ce21a910d4a4f7c81bd94e38135b8ac/","title":"Exercises 2.22","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2023%207330a82cf1f548bcbdf43c007406f577/","title":"Exercises 2.23","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2024%20c205fa5492d444c3b2cc5d4b9454580b/","title":"Exercises 2.24","text":"<p>Correctness: AC Tags: write boolean equations for a given circuit</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2025%202596dad93b8c45ff8aa5dde92e1a33e0/","title":"Exercises 2.25","text":"<p>Correctness: AC Tags: draw a circuit, minimize boolean equations</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%2026%20f39b5317a8844ad49337443018d8bd3a/","title":"Exercises 2.26","text":"<p>Correctness: AC Tags: bubble pushing, draw a circuit, write a boolean equation</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%203%20ada23e3d73794426b2e0e44b47c2a694/","title":"Exercises 2.3","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%204%20d8d0fa10640242549ac2aaf259835a4f/","title":"Exercises 2.4","text":"<p>Correctness: AC Tags: product-of-sums canonical form</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%205%2085cb6c6d12804795a1806ac5b11dee07/","title":"Exercises 2.5","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%206%205968a7d9755e41988c38661b734c4457/","title":"Exercises 2.6","text":"<p>Tags: minimize boolean equations</p>"},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%207%205969c6bf6662465a86b97eefd92d342a/","title":"Exercises 2.7","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%208%20f5759ca2ebea413ebce81971a793d586/","title":"Exercises 2.8","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Exercises%202%209%20a5e5451d2f604cd99e0004317ee34039/","title":"Exercises 2.9","text":""},{"location":"CS/ddca_self_study_colin_mufan/Digital%20Design%20and%20Computer%20Architecture%28%21%21%21%29%20935ed377ae204d42b7648117d32f3ac2/Exercises%202%20Checklist%204b2fba53abf840e59c03a948aa131dbe/Untitled%20e4ec046157c8474e9fbde4b77efb5e4d/","title":"Untitled","text":""}]}